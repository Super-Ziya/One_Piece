### Linux

####1、xshell

> 上传文件到服务器：`rz -y`
>
> 下载文件到本地：`sz + 文件`
>
> 获得权限：`sudo su` 回车后输入密码

#### 2、常用命令

>`ls` 列出文件夹里文件名称
>
>`ll` 查看文件夹信息，文件总数等详细信息
>
>`cd /` 回到主文件夹；`cd ..` 返回上一级目录
>
>`rm +文件` 删除文件（`-f` 强制删除）
>
>`rm -r +文件夹` 删除文件夹
>
>`mkdir +文件夹` 创建文件夹
>
>`mv 文件名 目标文件夹目录(例如/home/USER_zy)` 移动文件到目标文件夹
>
>`ps -ef|grep py` 查看当前进程
>
>`df -hl` 查看内存空间

####3、VI编辑

> 按ESC进入Command模式，输入
>
> > `：wq` 回车就是保存退出
> >
> > `w` 保存
> >
> > `wq!` 保存强制退出
> >
> > `q!` 强制退出

#### 4、Linux IPC 机制：

- 管道（pipe）：内核管理的缓冲区，半双工，只能用于父子进程/兄弟进程（fork、exec 创建）

  - 通过底层 read 和 write 调用来访问数据，写入、读取的顺序是先进先出
  - 写入的数据量不大于 PIPE_BUF 时，linux 保证写入原子性；大于不保证
  - 最后一个引用管道的进程终止后就会被删除

- 命名管道：克服管道弊端，允许没有亲缘关系的进程间通信，管道可以是事先创建好的

- 信号：用于一个或几个进程间传递异步信号，可以由各种异步事件产生，如键盘中断等

- 消息队列：**内核地址空间内部链表**（结构体结构，消息类型加消息数据），通过内核在各个进程传递内容，每个消息队列可用 IPC 标识符唯一识别，不同消息队列相互独立，每个队列维护一个结构体，保存消息队列当前状态信息（用户 id、组 id 等）

  - 克服信号承载信息少，管道只能承载无格式字符流

  - 进程终止时消息依然保留

  - 与命名管道相比：

    > 相同：可以不相关进程、发送接收传递数据、对每个数据都有长度限制
    >
    > 优势：
    >
    > - 可独立于发送、接收进程，消除同步命名管道的打开关闭的困难
    > - 避免命名管道的同步、阻塞问题，不需进程自己提供同步方法
    > - 可通过消息类型有选择性接收数据，命名管道只能默认接收

- 信号量：一种计数器（锁机制、PV 操作）

  - P（申请资源）：sv 大于 0，减 1；等于 0，挂起该进程
  - V（释放资源）：因等待 sv 而挂起的进程就运行；没有挂起进程加 1

- 共享内存：在多个进程之间共享内存区域，由 IPC 为进程创建一个特殊地址范围（在该进程的地址空间）。其他进程可将同一段共享内存连接到自己的地址空间中，所有进程都可访问共享内存中的地址。如果一个进程向共享内存写入了数据，改动将立刻被其他进程看到。多进程间的共享内存是同一块物理空间，仅映射到各进程的地址不同。**共享内存没有同步机制，需要程序员自己控制**

  - 和管道、消息队列等相比不用通过中间机制转换
  - 与信号量、命名管道相同：都有命名

- 内存映射：文件到一块内存的映射（类似虚拟内存），可以保留一个地址的区域，同时将物理存储器提交给此区域，内存文件映射的物理存储器来自一个已经存在于磁盘上的文件，而且在对该文件进行操作之前必须首先对文件进行映射。**使用内存映射文件处理存储于磁盘上的文件时不再对文件执行 I/O 操作**。 每一个使用该机制的进程通过把同一个共享的文件映射到自己的进程地址空间来实现多进程通信（类似共享内存，只要一个进程对这块映射文件的内存进行操作，其他进程也能马上看到）

  - 使用内存映射文件不仅可实现多进程通信，还可用于处理大文件提高效率。普通做法是把磁盘上文件先拷贝到内核空间一个缓冲区再拷贝到用户空间（内存），用户修改后再将这些数据拷贝到缓冲区再拷贝到磁盘文件，一共四次拷贝。内存映射真正拷贝是在缺页中断处理时进行，内存映射将文件直接映射到用户空间，中断处理函数根据这个映射关系直接将文件从硬盘拷贝到用户空间，只进行一次数据拷贝，效率高于 read/write

  - 与共享内存区别：

    > 内存映射文件利用虚拟内存把文件映射到进程的地址空间中去，此后进程操作文件就像操作进程空间地址。共享内存是内存映射文件一种特殊情况，内存映射是一块内存，而非磁盘上的文件。共享内存的主语是进程，操作系统默认会给每个进程分配一个内存空间，每个进程只允许访问操作系统分配的内存，不能访问其他进程的。操作系统给出创建访问共享内存的 API，需共享内存的进程可通过 API 访问多进程之间共有内存，各个进程访问这一段内存就像访问一个硬盘上的文件一样

  - 与虚拟内存区别：

    > 联系：两者都将一部分内容加载到内存，另一部分放在磁盘上。对用户透明
    >
    > 区别：虚拟内存是硬盘的一部分，是内存和硬盘的数据交换区。内存映射是一个文件到一块内存的映射，程序通过内存指针就可访问文件。虚拟内存的硬件基础是分页机制和局部性原理，将程序一部分装入内存，其余部分留在外存，访问信息不存在再将数据调入内存。而内存映射文件不是局部性，而是使虚拟地址空间某个区域映射磁盘的全部或部分内容，通过该区域对被映射磁盘文件进行访问，不必 I/O 和缓冲

- 套接字：明确地区分客户端与服务器，可实现多个客户端连到同一服务器

#### 5、IO多路复用

> 单线程或单进程同时监测若干个文件描述符是否可以执行 IO 操作的能力

- DMA（Direct Memory Access，直接存储器访问）：处理 IO

- Pagecache：Linux 内核所使用的主要磁盘高速缓存。内核读写磁盘时都用到 PageCache

  - 如果程序想读部分不在高速缓存，先申请一个 4KB 大小的新页框加到 PageCache，再用磁盘读到的数据填充

  - 写操作时，先把要写的数据写到 pageCache，标记当前页面为脏，然后程序自己调用系统调用刷盘，或等内核到自己的默认设置刷盘，没及时写时断电白写

- 文件描述符 fd：Linux 将一切抽象为文件，文件描述符用于对应打开/新建的文件，本质是个非负整数。实际上是个索引值，指向内核为每个进程所维护的该进程打开文件的记录表。程序打开现有或创建新文件时，内核向进程返回一个文件描述符

  - 每个进程一旦创建都有三个默认的文件描述符，u 代表读写都可
    - 0u（标准输入）
    - 1u（标准输出）
    - 2u（报错信息输出）

  - 每个文件描述符代表的数据结构中都有自己的偏移量，表示它可从当前文件哪个位置进行操作（读写）
  - 每个进程都有自己的文件描述符，因为进程隔离，不同进程维护的文件描述符可重复
  - 假如不同进程的相同文件描述符指向同一文件，仍各自维护自己的偏移量指针，每个进程可各自访问自己区域

- socket：socket 类型的文件描述符有自己的缓存数据区域，但不是要刷盘的，是要通过网卡发走的，中间经历各种网络协议包装成数据包发往目标 IP 地址

##### （1）select

- 把 readset 和 writeset 的文件描述符对应位置 1，交给 `select()` 系统调用判断哪个文件描述符打开（将读/写文件描述符集合从用户态拷贝到内核态中，在内核中判断事件来临，会阻塞），如果某个 fd 不可读/写，该位置 0，如果可读，数组中仍然为 1，系统调用后返回可读可写的数量和
- 循环遍历所有文件描述符用 FD_ISSET() 判断是否进行读写操作
- 有数据来临，FD 置位（不可重用），select 返回（不阻塞）

```c
int FD_ISSET(int fd,fd_set *fdset);  //返回值：若fd在文件描述符集中，返回非0值；否则，返回0
void FD_CLR(int fd,fd_set *fdset);   //清除最后一位
void FD_SET(int fd,fd_set *fdset);   //开启描述符中的一位
void FD_ZERO(fd_set *fdset);         //所有描述符位置位0

while(1){
    FD_ZERO(&rset);
    for(i=0;i<5;i+r){
        //&rset是文件描述符集合
        //如五个文件描述符存的12346，则&rset为0111101（有1024位）
	    FD_SET(fds[i],&rset);
    }
	//文件描述符最大值+1，读文件描述符集合，写文件描述符集合，异常文件描述符集合，超时时间
    //int select(int maxfpd1,fdset *read_fds,fdset *write_fds,fdset *exception_fds,struct timeval *restrict tvpr);
    select(max+1,&rset,NULL,NULL,NULL);//会阻塞
    for(i=0;i<5;i++){//再遍历
	    if(FD_ISSET(fds[i],&rset)){
		    memset(buffer,0,MAXBUF);
		    read(fds[i],buffer,MAXBUF);
            puts(buffer);
    }
}
```

- 优点：一次系统调用把所有 fds 传给内核，减少 BIO 多次调用的开销（假设 1000 个连接只有一个发来数据，BIO 需向内核发送 1000 次系统调用，999 次无意义，消耗时间和内存资源）
- 缺点
  - 最大文件描述符编号为 1024
  - 直接在 readset、writeset 做修改，不可重用
  - 用户态到内核态的切换开销
  - 不能返回哪位有事件，需再遍历

##### （2）poll

- 将rset从用户态拷贝到内核态中，在内核中判断事件来临（会阻塞）
- 有数据来临，pollfd.revents置位，poll返回（不阻塞）

```c
struct pollfd{
	int fd;
	short events;//在意的事件（POLLIN读、POLLOUT写）
    short revents;//events的回馈，默认0
}

while(1){
    puts("round again");
	//pollfd数组，元素个数，超时时间
    //int poll(struct pollfd fdarry[],nfds_t nfds,int timeout);
    poll(pollfds,5,50000);//会阻塞
    for(i=0;i<5;i++){//再遍历
	    if(pollfds[i].revents & POLLIN){
		    pollfds[i].revents = 0;//置0，可重用
		    memset(buffer,0,MAXBUF);
		    read(pollfds[i].fd,buffer,MAXBUF);
            puts(buffer);
        }
    }
}
```

- 优点
  - 内核操作的是结构体的 revents 字段，没有破坏其他字段，可复用
  - 没有 select 最大支持 1024 个文件描述符的限制
- 缺点
  - 每次 poll 都要重新遍历全量 fds
  - 不能返回哪位有事件，需再遍历

##### （3）epoll

![Linux_epoll](图片.assets\Linux_epoll.png)

- Linux 特有
- 把文件描述符放到内核一个事件表中，epoll 需用一个额外文件描述符表示内核中的事件表

```c
struct epoll_event{
    _uint32_t events; //epoll事件，读、写、异常三种
    epoll_data_t data; //用户数据
}
struct epoll_data{
    void* prt;
    int fd;
    _uint32_t u32;
    _uint64_t u64;
}epoll_data_t;

int epoll_create(int size);//返回一个文件描述符，描述的是内核中一块内存区域，size现在不起作用
//用来操作内核事件表，epfd表示epoll_create()返回的事件表，fd表示新创建的socket文件描述符
//op:
//EPOLL_CTL_ADD：事件表中添加一个文件描述符，内核应关注的socket事件在epoll_event结构体中，添加到事件表的文件描述符以红黑树形式存在，防止重复添加
//EPOLL_CTL_MOD：修改fd上注册的事件
//EPOLL_CTL_DEL：删除fd上注册的事件
int epoll_ctl(int epfd,int op,int fd,struct epoll_event *event);
int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout);//返回就绪文件描述符个数
```

- 工作模式
  - LT
    - fd 可读后，如果服务程序读走一部分就结束此次读取，LT 模式下该文件描述符仍然可读
    - fd 可写后，如果服务程序写了一部分就结束此次写入，LT 模式下该文件描述符仍然可写
  - ET
    - fd 可读后，如果服务程序读走一部分就结束此次读取，ET 模式下该文件描述符不可读，需等到下次数据到达时才变为可读，要保证循环读取数据，确保把所有数据读出
    - fd 可写后，如果服务程序写了一部分就结束此次写入，ET 模式下该文件描述符不可写，要写入数据，确保把数据写满