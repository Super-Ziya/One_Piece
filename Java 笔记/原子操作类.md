### 原子操作类

> JUC 包中的类为解决高并发而设计，包括原子操作类，底层基于 Unsafe 类的方法实现
>
> 原子操作类包括 AtomicInteger、AtomicLong、AtomicBoolean 等，功能和 Integer、Long、Boolean 类似，其是原子性操作，满足高并发，通过 CAS 实现高并发下代替 synchronize 实现更高效率
>
> 32 位操作系统中，64 位的 long 和 double 变量会被 JVM 当作两个分离的 32 位操作，不具有原子性

- Atomic 包提供 13 个类，分 4 种类型原子更新方式
  - 原子更新基本类型
  - 原子更新数组
  - 原子更新引用
  - 原子更新属性（字段）

#### 1、基本类型原子操作类

- Atomic 包提供 3 个基本类型原子操作类：AtomicBoolean、AtomicInteger、AtomicLong，其提供的方法几乎一样，以 AtomicInteger 为例，常用方法
  - `int addAndGet(int delta)`：以原子方式将输入数值与实例值（AtomicInteger 里的 value）相加并返回
  - `boolean compareAndSet(int expect，int update)`：如果输入数值等于预期值，以原子方式将该值设为输入值
  - `int getAndIncrement()`：以原子方式将当前值加 1，返回自增前的值，相当于 i++
  - `void lazySet(int newValue)`：JDK6 增加，最终会设成 newValue，使用 lazySet 设置值后，可能导致其他线程在之后一小段时间内还可读到旧值
  - `int getAndSet(int newValue)`：以原子方式设为 newValue 值，并返回旧值

- 其余的基本类原子操作类：java 基本类型有 8 个，JDK 只提供三个，Atomic 包基本都使用 Unsafe 实现

  - Unsafe 源码，只提供 3 种 CAS 方法

  ```java
  //如果当前数值是expected，原子的将Java变量更新成x，更新成功返回true
  public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x);
  
  public final native boolean compareAndSwapInt(Object o, long offset, int expected,int x);
  
  public final native boolean compareAndSwapLong(Object o, long offset, long expected, long x);
  ```

  - AtomicBoolean 源码：把 boolean 转成整型存储，使用 compareAndSwapInt 进行 CAS，其他基本类型的原子类型也可参照该思路实现（byte、char）

  ```java
  public class AtomicBoolean implements java.io.Serializable {
      //存储值：1（true）、0（false）
      private volatile int value;
      //Unsafe对象
      private static final Unsafe unsafe = Unsafe.getUnsafe();
  
      public final boolean compareAndSet(boolean expect, boolean update) {
          //boolean类型转成整形
          int e = expect ? 1 : 0;
          int u = update ? 1 : 0;
          return unsafe.compareAndSwapInt(this, valueOffset, e, u);
      }
  
      public final void set(boolean newValue) {
          value = newValue ? 1 : 0
      }
  
      public final boolean get() {
          return value != 0;
      }
      //.......
  }
  ```

  - Float 和 Double 的实现
    - Float 类中提供 static 两个方法：通过 `static int floatToIntBits(float value)`（根据 IEEE 754 浮点单一格式位布局，返回指定浮点值表示形式），将 float 以整形方式存储，取值通过 `static float intBitsToFloat(int bits)`，将存储的整形的浮点值转换回原来 float 值，Double 类也类似
    - 利用 AtomicReference 类，不可行，像 compareAndSet 这类方法比较的是对象内存地址，而不使用 `equal()` 比较
    - 使用 JDK1.8 新增方法 DoubleAdder、DoubleAccumulator，都适合多写少读

#### 2、数组原子操作类

- 通过原子方式更新数组某个元素，Atomic 包提供 3 个类，其方法几乎一样
  - AtomicIntegerArray：原子更新整型数组元素
  - AtomicLongArray：原子更新长整型数组元素
  - AtomicReferenceArray：原子更新引用类型数组里元素

- 以 AtomicIntegerArray 为例，主要提供原子方式更新数组里的整型
  - 构造方法
    - `AtomicIntegerArray(int length)`：创建给定长度的新 AtomicIntegerArray
    - `AtomicIntegerArray(int[] array)`：创建与给定数组具有相同长度的新 AtomicIntegerArray，并从给定数组复制其所有元素
  - 其常用方法
    - `int addAndGet(int i, int delta)`：原子方式将输入值与数组中索引 i 的元素相加
    - `boolean compareAndSet(int i, int expect, int update)`：如果当前值等于预期值，以原子方式将数组位置 i 的元素设置成 update 值
  - 数组 value 通过构造方法传递进去，AtomicIntegerArray 会将当前数组复制一份，当 AtomicIntegerArray 对内部数组元素修改时，不会影响传入的数组

#### 3、引用类型的原子操作类

- 基本类型的原子操作类只能更新基本类型值，Atomic 包提供三个类以原子方式更新对象引用
  - AtomicReference：原子更新引用类型
  - AtomicStampedReference：原子更新带版本号的引用类型，将整数值与引用关联，可用于原子更新数据和数据版本号，解决使用 CAS 进行原子更新时，可能出现的 ABA 问题
  - AtomicMarkableReference：原子更新带有标记位的引用类型，可原子更新一个布尔类型标记位和引用类型，构造方法 `AtomicMarkableReference(V initialRef, boolean initialMark)` 

##### 3.1、AtomicReference

- 构造方法
  - `AtomicReference()`：使用 null 初始值创建新 AtomicReference
  - `AtomicReference(V initialValue)`：使用给定初始值创建新 AtomicReference
- 常用的方法：`get()`、`set(V newValue)`、`compareAndSet(V expect, V update)`、`getAndSet(V newValue)` 
- AtomicReference 例子

```java
public class AtomicReferenceTest {

    public static AtomicReference<user> atomicUserRef = new AtomicReference<>();

    public static void main(String[] args) {
        User user = new User("conan", 15);
        atomicUserRef.set(user);
        User updateUser = new User("Shinichi", 17);
        atomicUserRef.compareAndSet(user, updateUser);
        System.out.println(atomicUserRef.get().getName());	//Shinichi
        System.out.println(atomicUserRef.get().getOld());	//17
    }

    static class User {
        private String name;
        private int old;

        public User(String name, int old) {
            this.name = name;
            this.old = old;
        }

        public String getName() { return name; }
        public int getOld() { return old; }
    }
}
```

##### 3.2、AtomicMarkableReference、AtomicStampedReference

- 作用与 AtomicReference 相似，都是原子更新引用类型，还能解决 CAS 中的 ABA 问题
- ABA 问题：在多线程环境下，线程 1 将 A 值赋给 B，然后 B 值又重新赋值 A，此时 A 已被修改一次但线程 2 不知，在 CAS 时认为 A 值没被修改过，所以进行修改，如果只对结果敏感，对修改次数不敏感，该问题无所谓
- 解决 ABA 问题：这两个类多维护一个标志位记录修改状态，或维护一个版本号记录修改次数，进行 CAS 时，也比较标志位或版本号
- AtomicMarkableReference 用标志位 mark（布尔类型）标志修改状态，源码

```java
//构造方法，initialRef是初始引用类型，initialMark是初始标志位
public AtomicMarkableReference(V initialRef,  boolean initialMark);

//CAS比较引用类型，还比较标志位
public boolean compareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark) {
    Pair<V> current = pair;
    return expectedReference == current.reference && expectedMark == current.mark && ((newReference == current.reference && newMark == current.mark) || casPair(current, Pair.of(newReference, newMark)));
}
```

- AtomicStampedReference 用版本号 stamp（整形）记录修改次数，源码

```java
//构造方法，初始引用类型和初始版本号
public AtomicStampedReference(V initialRef, int initialStamp);

//CAS比较引用类型，还比较版本号
public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) {
    Pair<V> current = pair;
    return expectedReference == current.reference && expectedStamp == current.stamp && ((newReference == current.reference && newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp)));
}
```

#### 4、更新字段的原子操作类

- 如果只需某类里某字段，就需用原子更新字段类，Atomic 包提供三个类
  - AtomicIntegerFieldUpdater：原子更新整型字段的更新器，通过静态工厂方法创建 `newUpdater(Class tclass, String fieldName)`
  - AtomicLongFieldUpdater：原子更新长整型字段的更新器，通过静态工厂方法创建 `newUpdater(Class tclass, String fieldName)`
  - AtomicReferenceFieldUpdater：原子更新引用类型里的字段，比前两个范围广，可更新任意类型字段，通过静态工厂方法创建 `newUpdater(Class tclass, Class vclass, String fieldName)`
- 原子更新字段类都是抽象类，每次使用必须使用静态方法 newUpdater 创建一个更新器
- 原子更新类字段必须使用 public volatile 修饰符
- AtomicIntegerFieldUpdater 例子

```java
public class AtomicIntegerFieldUpdaterTest {

    private static AtomicIntegerFieldUpdater<User> a = AtomicIntegerFieldUpdater.newUpdater(User.class, "old");

    public static void main(String[] args) {
        User conan = new User("conan", 10);
        System.out.println(a.getAndIncrement(conan));	//10
        System.out.println(a.get(conan));	//11
    }

    public static class User {
        private String name;
        public volatile int old;

        public User(String name, int old) {
            this.name = name;
            this.old = old;
        }

        public String getName() { return name; }
        public int getOld() { return old; }
    }
}
```





