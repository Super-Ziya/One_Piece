

## JVM

### 一、内存与垃圾回收

#### 1、JVM 与 java 体系结构

- java 虚拟机 JVM 只关心“字节码”文件，具有语言无关性
- JVM 整体结构（HotSpot 虚拟机）

<img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第02章_JVM架构-简图.jpg" alt="第02章_JVM架构-简图" style="zoom: 50%;" />

- 详细结构

<img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第02章_JVM架构-英.jpg" alt="第02章_JVM架构-英" style="zoom: 50%;" />

---

<img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第02章_JVM架构-中.jpg" alt="第02章_JVM架构-中" style="zoom: 50%;" />

#### 2、JVM 结构模型

> java 编译器输入指令基于栈的指令集架构，另一种是基于寄存器的指令集架构
>
> 两种架构的特点
>
> 一般与硬件挂钩的虚拟机性能都较好，而跨平台的性能较差

- 基于栈式架构特点
  - 设计和实现更简单，适用于资源受限的系统
  - 避开了寄存器分配难题，使用零地址（没有地址，只有操作数，因为每次访问只涉及到栈顶）指令方式分配
  - 指令流中的指令大部分是零地址指令，执行过程依赖操作栈，指令集小（但是指令多），编译器容易实现
  - 不需要硬件支持，可移植性好，更好实现跨平台
- 基于寄存器架构的特点
  - 典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机
  - 指令集架构完全依赖硬件，可移植性差
  - 性能优秀和执行更高效
  - 花费更少的指令去完成一项操作
  - 大部分情况下，基于寄存器架构的指令集都以一地址（一个地址和一个操作数）、二地址（两个地址和一个操作数）、三地址指令为主，基于栈式架构的指令集以零地址指令为主

#### 3、JVM 生命周期

- 虚拟机的启动：通过引导类加载器创建一个初始类，该类由虚拟机的具体实现指定
- 虚拟机的执行：执行 Java 程序，其实是在执行一个 Java 虚拟机的进程
  - 程序开始执行时运行，程序结束时结束
- 虚拟机的退出：
  - 程序正常执行结束
  - 程序执行时遇到异常或错误而异常终止
  - 操作系统错误导致虚拟机进程终止
  - 某线程调用 Runtime 类或 System 类的 `exit` 方法，或 Runtime 类的 `halt` 方法，并且虚拟机安全管理器也允许此次操作
  - JNI 规范描述用 JNI Invocation API 来加载或卸载虚拟机时也会退出

#### 4、类加载器与类加载过程

- 类加载器子系统作用
  - 负责从文件系统或网络中加载 Class 文件，class 文件在文件开头有特定的文件标识（CA FE BA BE）
  - ClassLoader 只负责 class 文件的加载，能否运行由 Execution Engine（执行引擎）决定
  - 类信息存放于方法区的内存空间，方法区中还会存放运行时常量池信息，可能包含字符串字面量和数值常量（这部分常量信息是 class 文件中常量池部分的内存映射）

<img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第02章_类加载器子系统.jpg" alt="第02章_类加载器子系统" style="zoom:33%;" />

- 类加载器 ClassLoader 角色
  - class file 存在于本地硬盘上，执行时根据该文件实例化几个模板实例加载到 JVM 中，称为 DNA 元数据模板，存放于方法区中（ClassLoader 在 .class -> JVM -> 元数据模板 中作为运输工具）

<img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第02章_类加载器.jpg" alt="第02章_类加载器" style="zoom:80%;" />

---

- 类加载过程

  - 加载：

    - 通过类的全限定名获取定义此类的二进制字节流
    - 将字节流代表的静态存储结构转化为方法区的运行时数据结构
    - 在内存中生成一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口

  - 链接：

    - 验证：

      > 确保 Class 文件的字节流包含信息符合虚拟机要求，保证类加载的正确性，不会危害虚拟机自身安全
      >
      > 四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证

    - 准备：

      > 为变量分配内存并设置变量的默认初始值（零值），即使赋值 `x = 1` ，也会先赋为 0
      >
      > 不包括 final 修饰的 static，final 在编译时分配，准备阶段会显示初始化，即上式直接赋值 1
      >
      > 不会位实例变量分配初始化，类变量会分配在方法区中，实例变量随着对象一起分配在 java 堆中

    - 解析：

      > 将常量池内的符号引用转换为直接引用的过程
      >
      > 解析往往伴随着 JVM 执行完初始化后执行
      >
      > 符号引用：一组符号描述引用的目标。直接引用是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
      >
      > 解析动作主要针对类、接口、字段、类方法、接口方法、方法类型等，对于常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等

  - 初始化：

    - 执行类构造器方法 `<clinit>()` 的过程，该方法不需定义，是 javac 编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来
    -  `<clinit>()` 不同于类构造器（关联：构造器是虚拟机视角下的 `<init>()`。一个类声明后，内部至少存在一个类构造器： `<init>()` 方法）
    - 构造器方法中指令按语句在源文件中出现的顺序执行
    - 若该类有父类，JVM 会保证子类 `<clinit>()` 执行前，父类的 `<clinit>()` 已经执行完毕
    - 虚拟机必须保证一个类的 `<clinit>()` 方法在多线程下被同步加锁

  ```java
  private static int num = 1;
  
  static{
      num = 2;
      number = 20;
      System.out.println(num); //合法
      System.out.println(number); //报错：非法的前向引用
  }
  //linking的prepare：number = 0 -> initial：20 -> 10
  private static int number = 10;
  
  System.out.println(num); //2
  System.out.println(number); //10
  ```

  

<img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第02章_类的加载过程.jpg" alt="第02章_类的加载过程" style="zoom:33%;" />

---

- 类加载器分类
  - 引导类加载器（启动类加载器）（C\C++ 实现）

    - 不继承自 `java.lang.ClassLoader` ，没有父加载器
    - 用来加载 java 核心库（`JAVA_HOME/jre/lib/rt.jar`、`resources.jar` 或 `sun.boot.class.path` 路径下的内容）
    - 加载扩展类和应用程序类加载器，并指定为其父类加载器

  - 自定义类加载器（所有派生于抽象类 ClassLoader 的类加载器，广义上扩展类加载器和系统类加载器（Java 实现）都间接继承了 ClassLoader，所以属于自定义类加载器）

    - 扩展类加载器：

      > 父类加载器为启动类加载器
      >
      > 从 `java.ext.dirs` 系统属性所指定的目录中加载类库，或从 JDK 安装目录的 `jre/lib/ext` 子目录（扩展目录）下加载类库，用户创建的 JAR 放在此目录中也会自动由扩展类加载器加载

    - 应用程序类加载器（系统类加载器）

      > 父类加载器为扩展类加载器
      >
      > 负责加载环境变量 classpath 或系统属性 `java.class.path` 指定路径下的类库
      >
      > 程序的默认类加载器，java 应用类基本都是由其完成加载

    - 自定义加载器

      > 隔离加载类：使用多个框架时类名、路径可能相同，需要仲裁隔离加载
      >
      > 修改类加载方式
      >
      > 扩展加载源
      >
      > 防止源码泄露

    - 实现自定义类加载器

      > 继承 `java.lang.ClassLoader`，自定义类加载逻辑写在 `findClass()` 方法中
      >
      > 若无复杂需求，可直接继承 `URLClassLoader` 类，避免编写  `findClass()` 方法及其获取字节码流的方式

  ```java
  public class ClassLoaderTest(){
      //获取系统类加载器
      ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
      System.out.println(systemClassLoader); //* 处
      //获取其上层：扩展类加载器
      ClassLoader extClassLoader = systemClassLoader.getParent();
      //再获取其上层：获取不到引导类加载器
      ClassLoader bootstrapClassLoader = extClassLoader.getParent();
      System.out.println(bootstrapClassLoader); //null
      //对用户自定义类：默认使用系统类加载器加载
      ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
      System.out.println(classLoader); //与 * 处一致
      //String 类使用引导类加载器加载（Java 核心类库都使用引导类加载器加载）
      ClassLoader classLoader1 = String.class.getClassLoader();
      System.out.println(classLoader1); //null
  }
  ```

---

- ClassLoader

  | 方法名                                              | 描述                                                         |
  | --------------------------------------------------- | ------------------------------------------------------------ |
  | `getParent()`                                       | 返回类加载器的超类加载器                                     |
  | `loadClass(String name)`                            | 加载名称为 name 的类，返回 `java.lang.Class` 类型的实例      |
  | `findClass(String name)`                            | 查找名称为 name 的类，返回 `java.lang.Class` 类型的实例      |
  | `findLoadClass(String name)`                        | 查找名称为 name 的被加载过的类，返回 `java.lang.Class` 类型的实例 |
  | `defineClass(String name,byte[] b,int off,int len)` | 把字节数组 b 中的内容转换为一个 Java 类，返回 `java.lang.Class` 类型的实例 |
  | `resolveClass(Class<?> e)`                          | 连接指定的 Java 类                                           |

- 获取 ClassLoader

  | 方法一：获取当前类的 CLassLoader                            |
  | ----------------------------------------------------------- |
  | `clazz.getClassLoader()`                                    |
  | **方法二：获取当前线程上下文的 ClassLoader**                |
  | `Thread.currentThread().getClassLoader()`                   |
  | **方法三：获取系统的 ClassLoader**                          |
  | `ClassLoader.getSystemClassLoader()`                        |
  | **方法四：获取调用者的 ClassLoader （涉及本地方法的调用）** |
  | `DriverManager.getCallerClassLoader()`                      |

#### 5、双亲委派机制

- 原理
  - 一个类加载器在收到类加载请求时不会自己加载，会把请求委托给父类加载器执行
  - 如果父类加载器也存在父类加载器，则一步步向上委托，请求最终交由顶层启动类加载器执行
  - 父类加载器可以完成类加载就成功返回，不可以就交还给子加载器尝试加载
- 优势
  - 避免类的重复加载
  - 保护程序安全，防止核心 API 被篡改

<img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第02章_双亲委派机制.png" alt="第02章_双亲委派机制" style="zoom:80%;" />

- 沙箱安全机制

  > 自定义 String 类，在加载时会使用引导类加载器，而引导类加载器会加载 jdk 自带文件（rt.jar 包下的 java\lang\String.class），会报错，保证对 java 核心源代码的保护

#### 6、其他

-  JVM 中两个 class 对象为同一个类的必要条件

  > 类的类名、包名一致
  >
  > 加载类的 ClassLoader 一致

- java 对类的使用

  - 主动使用

    - 创建类实例

    - 访问类、接口的静态变量，或对其赋值

    - 调用类的静态方法

    - 反射

    - 初始化类的子类

    - 虚拟机启动时被标明为启动类的类

    - jdk 7 开始提供动态语言支持：

      > `java.lang.invoke.MethodHandle` 实例解析结果
      >
      > `REF_getStatic`、`REF_putStatic`、`REF_invokeStatic` 句柄对应类没有初始化，则初始化

  - 被动使用

    > 不会导致类的初始化，而主动使用会初始化

- 反编译

  - 在类的目录下 `javap -v XXX.class` 

#### 7、JVM 线程

- 允许多线程并行执行
- HotSpot JVM 中每个线程都与操作系统的本地线程直接映射
- 分类
  - 守护线程：专为其他线程服务的线程，比如计时，虚拟机只剩下守护线程就可以退出
  - 普通线程
- 系统线程
  - 虚拟机线程：JVM 到达安全点出现，执行类型包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起及偏向锁撤销
  - 周期任务线程：周期性操作的调度执行，如中断
  - GC 线程：对 JVM 里不同种类的垃圾收集提供支持
  - 编译线程：在运行时会将字节码编译成本地代码
  - 信号调度线程：接收信号发送给 JVM，在其内部通过适当方法处理

#### 8、程序计数器

- 作用

  > 用来存储指向下一条指令（将要执行的指令）的地址，由执行引擎读取

- 其他

  - 内存空间小，几乎可忽略不计，运行速度最快的存储区域
  - 线程私有，生命周期与线程的一致
  - 任一时间只有一个方法在执行（当前方法），程序计数器存储当前线程正在执行的 java 方法的 JVM 指令地址，若执行 native 方法（本地方法栈），则未指定值（undefined）
  - 程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能
  - 字节码解释器通过改变计数器的值来获取下一条执行指令
  - 唯一一个在虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域（无 OOM，也无 GC）

#### 9、虚拟机栈

> 每个线程在创建时会对应创建一个虚拟机栈，其内部保存一个个栈帧，对应一次次的方法调用
>
> 线程私有，生命周期与线程一致（方法区和堆是共享的）
>
> 主管 Java 程序的运行，保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，参与方法的调用和保存
>
> 不同栈帧不存在相互引用
>
> 当前方法调用其他方法时，在返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着出栈，使前一个栈帧成为当前栈（两种返回函数方式，正常返回 return 和抛出异常，两者都会导致栈帧被弹出）

- 特点
  - 快速有效的分配存储方式，访问速度仅次于程序计数器
  - 不存在垃圾回收问题（无 GC，有 OOM）
  - JVM 对其操作：
    - 每个方法执行，入栈
    - 执行结束，出栈
- 可能出现的异常
  - StackOverflowError 异常：采用固定大小的虚拟机栈时，每个线程的虚拟机栈容量可以在线程创建时独立选定（使用 `-Xss` 参数设置），如果请求分配的栈容量超过虚拟机容许的最大容量就抛出该异常
  - OutOfMemoryError 异常：若虚拟机可动态扩展，且在尝试扩展时没有申请到足够的内存，或在创建新线程时没有足够的内存去创建对应的虚拟机栈，就会抛出该异常
- 栈帧结构
  - 局部变量表
  - 操作数栈（表达式栈）
  - 动态链接（指向运行时常量池的方法引用）
  - 方法返回地址
  - 一些附加信息

<img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第05章_栈桢内部结构.jpg" alt="第05章_栈桢内部结构" style="zoom:33%;" />

- 局部变量表

  > 定义为一个数字数组，主要存储方法参数和定义在方法体中的局部变量，数据类型包括各类基本数据类型、对象引用以及 returnAddress 类型（byte、short、char、boolean 在存储前被转换为 int 类型）
  >
  > 线程私有，不存在数据安全问题
  >
  > 容量大小在编译期确定，保存在方法的 Code 属性的 maximum local variables 数据项中，方法运行期间不会改变局部变量表大小
  >
  > 方法嵌套次数由栈大小决定，参数和局部变量越多，局部变量表越膨胀，栈帧越大，函数调用就会占用更多栈空间，导致调用次数减少

- slot（槽）

  > 局部变量表最基本的存储单元，局部变量表中 32 位以内的类型占用一个 slot，64 位的类型占用两个 slot
  >
  > 若当前帧由构造方法或实例方法创建的，该对象引用 this 将会存放在 index 为 0 的 slot 处，静态方法块不能使用 this，因为 this 变量不存在当前方法的局部变量表中
  >
  > 栈帧中的局部变量表中的槽位可以重复利用，局部变量过了作用域就可能被新声明的局部变量使用

  ```java
  public void test(){
      int a = 0;
      {
          int b = 0;
          b = a + 1;
      }
      //c 使用已销毁变量 b 占据的 slot 的位置
      int c = a + 1;
  }
  ```

- 操作数栈

  > 数组实现，并非采用索引进行数据访问，只能通过标准的入栈出栈操作完成
  >
  > 主要用于保存计算过程的中间结果，同时作为计算过程的变量临时存储空间
  >
  > 操作数栈是 JVM 执行引擎的一个工作区，方法执行时会创建新栈帧，对于的操作数栈是空的，操作数栈深度在编译期就定义好
  >
  > 栈中任一元素都可以是任意 Java 数据类型，32bit 的类型占一个栈单位深度，64bit 的占两个，操作数栈中元素数据类型必须和字节码指令序列严格搭配，由编译器在编译期间验证，同时在类加载过程的类检验阶段的数据流分析再次验证
  >
  > 方法执行中，根据字节码指令，往栈中写入数据（入栈）或提取数据（出栈），若方法带有返回值的话，其返回值将会被压入当前栈的操作数栈中，并更新 PC 寄存器中的下一条字节码指令
  >
  > 某些字节码指令将值压入或取出操作数栈，执行复制、交换、求和等操作

- 栈顶缓存技术

  > 将栈顶的元素全部缓存在物理 CPU 的寄存器中，降低对内存的读写次数，提升执行引擎的执行效率
  
- 动态链接（指向运行时常量池的方法引用）

  > 每个栈帧内包含一个指向运行时常量池中该栈帧所属方法的引用，目的是为了支持当前方法的代码能实现动态链接，如 invokedynamic 指令
  >
  > java 源文件编译到字节码文件中时，所有变量和方法引用都作为符号引用保存在 class 文件的常量池中，一个方法调用其他方法就是通过常量池中指向方法的符号引用来表示的，动态链接的作用是将这些符号引用转换为调用方法的直接引用

<img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第05章_栈桢内部结构.jpg" alt="第05章_栈桢内部结构" style="zoom:33%;" />

- 方法的调用
  - 静态链接：字节码文件装载进 JVM 内部时，若调用的方法在编译器可知，且运行期保持不变，将调用方法的符号引用转换为直接引用的过程

  - 动态链接：若调用方法在编译器不确定，即只能在程序运行期将调用方法的符号引用转换为直接引用

  - 绑定：一个字段、方法、类在符号引用被替换成直接引用的过程
    - 早期绑定：调用的方法在编译期可知，且运行期不变，可将该方法与所属类型绑定，可以使用静态链接
    - 晚期绑定：被调用方法在编译期无法确定（多态），只能在运行期根据实际类型绑定相应方法，对应动态链接
    
  - 非虚方法

    > 若方法在编译期就确定了具体的调用版本，该版本在运行时不可变，这样的方法为非虚方法
    >
    > 静态方法、私有方法、final 方法（前三都不能被重写）、实例构造器（重构）、父类方法
    >
    > 其他方法为虚方法（多态）
    >
    > 子类对象多态使用前提：类的继承关系、方法的重写

  - 虚拟机方法调用指令

    - 普通方法调用指令

      > `invokestatic`：调用静态方法，解析阶段唯一确定方法版本
      >
      > `invokespecial`：调用 `<init>` 方法、私有方法、父类方法，解析阶段唯一确定方法版本
      >
      > `invokevirtual`：调用所有虚方法
      >
      > `invokeinterface`：调用接口方法

    - 动态调用指令

      > `invokedynamic`：动态解析出需要调用的方法，然后执行（lambda 表达式）

  - 方法重写的本质

    > 找到操作数栈顶第一个元素所执行对象的实际类型，记作 C
    >
    > 若在 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，通过就返回该方法的直接引用，查找过程结束，若不通过则返回 java.lang.IllegalAccessError 异常（程序试图访问或修改一个属性或调用一个方法，而没有权限访问，一般会引起编译器异常，若发生在运行时，说明一个类发生不兼容的改变）
    >
    > 否则按照继承关系从下往上依次对 C 各父类进行第 2 步的搜索验证
    >
    > 若始终没有找到合适方法，抛出 java.lang.AbstractMethodError 异常

  - 虚方法表

    > 每次动态分配都要重新在方法元数据中搜索会影响执行效率，JVM 在类的方法区建立一个虚方法表，使用索引代替查找
    >
    > 每个类中都有一个虚方法表，存放各个方法的实际入口
    >
    > 在类加载的链接阶段创建并初始化，类变量初始值准备完成后，JVM 把该类的方法表也初始化完毕

- 方法返回地址

  > 存放调用该方法的 PC 寄存器的值
  >
  > 正常退出调用该方法的下一条指令地址，异常退出时返回地址通过异常表确定，方法返回地址主要针对正常返回

- 面试题

  - 栈溢出情况（StackOverflowError）

    - 通过 -Xss 设置栈的大小；动态扩容也空间不足时 OOM
    - 调整栈大小，不能保证不出现溢出（死循环等）
    - 分配栈内存越大越好？整个内存空间有限，一个栈内存变大，线程就变少

  - 垃圾回收是否会涉及到虚拟机栈

    - 不会

      |                      | Error | GC   |
      | -------------------- | ----- | ---- |
      | 程序计数器           | 无    | 无   |
      | 虚拟机栈、本地方法栈 | 有    | 无   |
      | 方法区、堆           | 有    | 有   |

  - 方法中定义的局部变量是否线程安全？具体问题具体分析

    - 线程安全：只有一个线程操作必是线程安全；若多个线程操作，此数据为共享数据，若不考虑同步机制，会存在线程安全问题

    ```java
    //线程安全：局部变量内部产生内部消亡
    public static void method1(){
        StringBuilder s1 = new StringBuilder();
        s1.append("a");
        //...
    }
    //线程不安全：不是内部产生
    public static void method2(StringBuilder sb){
        sb.append("a");
        //...
    }
    //线程不安全：不是内部消亡
    public static StringBuilder method3(){
        StringBuilder s1 = new StringBuilder();
        s1.append("a");
        return s1;
    }
    //线程安全
    public static String method4(){
        StringBuilder s1 = new StringBuilder();
        s1.append("a");
        return s1.toString();
    }
    ```

#### 10、本地方法

- 本地方法使用场景

  - 与 Java 环境外交互（底层系统）
  - 与操作系统交互，JVM 运行于底层操作系统之上，设置一部分 JVM 用 C 写的
  - Sun`s Java，jre 大部分用 java 实现，也通过本地方法与外界交互

- 本地方法栈

  > 管理本地方法的调用
  >
  > 线程私有，允许固定或可动态扩展的内存（和虚拟机栈一样），权限也和虚拟机一样
  >
  > 可以直接使用本地处理器的寄存器，从本地堆中分配任意内存
  >
  > 本地方法登记本地（native）方法，在执行引擎执（Execution Engine）行时加载本地方法库
  >
  > HotSpot JVM 将本地方法栈和虚拟机栈合二为一，其他虚拟机有可能没有本地方法栈

#### 11、堆

> 堆在 JVM 启动时创建，空间大小确定（堆大小可调节），内存空间最大
>
> 所有对象实例及数组在运行时分配在堆上，栈帧中保存指向堆中位置的引用
>
> 方法结束后，堆中对象不会马上移除，仅在垃圾回收时移除（堆是 GC 重点区域）
>
> 在物理上可以是不连续的内存空间，但在逻辑上应该连续
>
> 线程共享，可以划分线程私有缓冲区

- 内存细分（堆一般包含新生区和养老区）

  > java7 前：新生区+养老区+永久代
  >
  > java8 及以后：新生区+养老区+元空间
  >
  > 年轻代 : 年老代 = 1 : 2

  - 年轻代

    > Eden : Survivor0 : Survivor1 = 8 : 1 : 1，一般会自适应而不是 8 : 1 : 1
    >
    > 绝大部分对象的销毁在新生代中

    - Eden 空间

      > 几乎所有对象在 Eden new 出来的

    - Survivor0 空间（from 区）

    - Survivor1 空间（to 区）

  - 年老代

  <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第08章_堆空间细节.jpg" alt="第08章_堆空间细节" style="zoom: 33%;" />

- 堆空间大小设置

  - `-Xms` （memory start）表示起始内存
  - `-Xmx` 表示最大内存，超过该值抛出 OutOfMemoryError 异常
  - `-Xmn` 设置新生代空间大小（无视新老比例）
  - `-XX: NewRatio=n` 新生代 : 老年代 = 1 : n
  - `-XX: SurvivorRatio=n` Eden : Survivor0 : Survivor1 = n : 1 : 1
  - 通常让 `-Xms` 和 `-Xmx` 配置值一样，目的是提高 java 垃圾回收机制清理完后不需重新分隔计算堆大小，提高性能
  - 默认：
    - 初始内存大小：物理电脑内存 / 64
    - 最大内存大小：物理电脑内存 / 4
  - 查看堆内存分配
    - jps / jstat -gc 进程id
    - -XX: +PrintGCDetails

- 对象分配过程

  - new 的对象先放在伊甸园区，此区有大小限制，大对象直接放老年代

  - 当伊甸园区满，有新建对象时，JVM 垃圾回收器对伊甸园区进行垃圾回收（Minor GC，**幸存者区满不会触发垃圾回收**），销毁不再被其他对象引用的对象，而剩余对象放进幸存者 0 区，年龄为 1，将新对象放到伊甸园区

    - 在 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间

      > 大于则此次 Minor GC 是安全的
      >
      > 小于，虚拟机会查看 `-XX:HandlePromotionFailure` 设置值是否允许担保失败（在 jdk7 及之后默认为 true，该参数不会影响到虚拟机分配担保策略）
      >
      > - true，继续检查老年代最大可用连续空间是否大于晋升到老年代的对象平均水平
      >   - 大于，尝试进行一次 Minor GC，但有风险
      >   - 小于，进行一次 Full GC
      > - false，进行一次 Full GC

  - 若再次触发垃圾回收，幸存者 0 区中美有被回收的会放进幸存者 1 区，依次循环，年龄递增（谁空谁是 to  区，不空是 from 区）

  - 默认年龄超过 15 后进入养老区，若幸存者区中相同年龄的所有对象大小总和大于幸存者区的一半，年龄大于或等于该年龄的对象可直接进入养老区，养老区内存不足时再次触发 GC（Major GC），进行养老区内存清理，若 GC 后依然无法保存对象，产生 OOM 异常
    
    - `-XX:MaxTenuringThreshold=n`：设置多少次进入养老区
    
  - 垃圾回收频繁在新生区收集，很少在养老区收集，几乎不再永久区/元空间收集

  <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第08章_新生代对象分配与回收过程.jpg" alt="第08章_新生代对象分配与回收过程" style="zoom:25%;" />

  - 对象分配

  <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第08章_对象存活机制.png" alt="第08章_对象存活机制"  />

- 三种 GC

  - 部分收集（Partial GC）

    - 新生代收集（Minor GC）：只是新生代的垃圾收集

      > 年轻代空间不足引起，Survivor 满不会引起，幸存者区的垃圾回收是被动的
      >
      > 频繁、回收速度块、会引发 STW（暂停其他用户线程）

    - 老年代收集（Major GC）：只是老年代的垃圾收集

      > 只有 CMS GC 有单独收集老年代的行为
      >
      > 对象从老年代消失时调用 Major GC 或 Full GC
      >
      > Major GC 经常伴随着至少一次的 Minor GC（老年代空间不足时会尝试 Minor GC，再 Major GC）
      >
      > 速度比 Minor GC 慢 10 倍以上，STW 时间更长
      >
      > Major GC 后内存仍然不足报 OOM

    - 混合收集（Mixed GC）：收集整个新生代和部分老年代的垃圾收集

      > 目前只有 G1 GC 有

  - 整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集

    > 开发和调优中尽量避免，使暂停时间短一些

    - 调用 `System.gc()` 时建议系统执行 Full GC，不必然执行
    - 老年代空间或方法区空间不足时触发
    - Minor GC 后进入老年代的平均大小大于老年代的可用内存时触发
    - 由 Eden、From 区向 To 区复制时，对象大小大于 To 区可用内存，把、转存到老年代，且老年代可用内存小于该对象大小时触发

- 堆分代思想

  > 为什么 java 堆分代：不同对象的生命周期不同，70%-99%的对象是临时对象，可用回收，分代是为了优化 GC 性能

- TLAB

  > 在 Eden 区中 JVM 为每个线程分配了一个私有缓存区域（默认占 1%），对象在 TLAB 空间分配内存失败时，JVM 会尝试使用加锁机制确保数据操作的原子性，直接在 Eden 空间中分配内存
  >
  > `-XX:UseTLAB` 设置是否开启 TLAB 空间，默认开启
  >
  > `-XX:TLABWasteTargetPercent` 设置 TLAB 空间占比

  <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第08章_TLAB.jpg" alt="第08章_TLAB" style="zoom: 33%;" />

  - 为什么有 TLAB：
    - 对象实例的创建在 JVM 中很频繁，在并发环境下从堆中划分内存空间是线程不安全的，为避免多个线程操作同一地址，需要加锁等机制，影响分配速度
    - 使用 TLAB 可以避免一系列非线程安全问题，提升内存分配吞吐量（快速分配策略）

  <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第08章_TLAB分配.png" alt="第08章_TLAB分配" style="zoom:80%;" />

- 堆外存储

  > 如果经过逃逸分析（Escape Analysis）后，一个对象没有逃逸出方法时，可能被优化成栈上分配，无须进行垃圾回收
  >
  > Taobao VM（基于 OpenJDK 深度定制）使用 GCIH（GC invisible heap）技术实现 off-heap，将生命周期较长的对象从 heap 中移至 heap 外，且 GC 不能管理 GCIH 内的对象，降低 GC 回收频率和提升回收效率

- 逃逸分析

  > 分析新对象的引用的使用范围，即分析对象动态作用域
  >
  > - 对象在方法中定义，只在方法内部使用，认为没有发生逃逸
  > - 对象在方法中定义，在方法外引用，认为发生逃逸
  >
  > 有效减少 java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法
  >
  > jdk7 及以后默认开启逃逸分析
  >
  > `-XX:+\-DoEscapeAnalysis` 开启\关闭逃逸分析，前提是启动 Server 模式：`-server` 

  - 栈上分配

    > JIT 编译器判断对象有没有逃逸，没有的话可能被优化成栈上分配，继续调用栈内执行，线程结束后栈空间被回收，局部变量对象也被回收，无需垃圾回收
    >
    > 逃逸场景：分别给成员变量赋值，方法返回值，实例引用传递

  - 同步省略

    > JIT 编译器借助逃逸分析判断同步块所使用的锁对象是否只能被一个线程访问而没有发布到其他线程，若没有 JIT 编译器在编译该同步块时会取消这部分代码的同步（字节码还是有同步的，也叫锁消除），提高并发性和性能
    >
    > 线程同步代价高，降低并发性和性能

  - 分离对象或标量替换

    > 标量：一个无法再分解成更小的数据的类型，如原始数据类型
    >
    > 聚合量：可以分解的数据，如对象
    >
    > 标量替换：JIT 编译器经过逃逸分析发现一个对象不会被外界访问时会把该对象拆解成若干个其中包含的成员变量代替（存放在局部变量表中）
    >
    > 大大减少堆内存空间
    >
    > `-XX:+\-EliminateAllocations` 开启\关闭标量替换（默认开启）

#### 12、方法区

> 与堆一样，物理内存可以不连续，但是逻辑连续，共享的区域
>
> 与堆一样，可以选择固定大小或者可扩展
>
> jdk7 及之前是永久代，jdk8 及之后是元空间，两者区别：元空间不在虚拟机设置的内存中，而是使用本地内存，内部结构也有调整
>
> 方法区大小决定了系统可以保存多少个类，系统定义太多的类（加载太多的第三方 jar 包）会导致溢出 OOM，关闭 JVM 可以释放该区域的内存

<img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第09章_栈、堆、方法区.jpg" alt="第09章_栈、堆、方法区" style="zoom:80%;" />

- 为什么元空间替换永久代

  > 两者最大区别：元空间不在虚拟机中，大小仅受本地内存限制

  - 永久代设置空间大小很难确定：若动态加载类过多，容易产生 Perm 区的 OOM，如果设置空间小，容易引起 Full GC，影响性能
  - 对永久代调优困难

- 为什么 String Table 要调整

  > 永久代回收效率低，Full GC 时才会触发，而 Full GC 触发是老年代空间不足、永久代不足，而开发中会有大量字符串被创建

- 内存大小设置

  > jdk7 前 `-XX:PermSize` 设置永久代初始分配空间（默认 20.75M），`-XX:MaxPermSize` 设置永久代最大可分配空间（32 位默认 64M，64 位默认 82M，超过报 OOM）
  >
  > jdk8 后 `-XX:MetaspaceSize` 和 `-XX:MetaspaceSize` 代替以上两个参数，默认值依赖平台，如 windows下，前者是 21M，后者是 -1M，即无限制，溢出也报 OOM
  >
  > 与永久代不同，元空间若不指定大小，在默认情况下虚拟机会耗尽所有可用系统内存
  >
  > `-XX:MetaspaceSize` 像一个水位线，触及时会触发 Full GC，然后重置水位线，值取决于GC后释放的空间，释放不足，会提高，释放过多，会降低， `-XX:MetaspaceSize` 设置太低会引发多次 GC，建议设置高一点
  >
  > 只有 HotSpot 才有永久代：
  >
  > - jdk 1.6及之前：永久代，静态变量存放在永久代上
  > - jdk 1.7：有永久代但字符串常量池、静态变量保存在堆中
  > - jdk 8及之后：无永久代，字段、方法、常量保存在元空间，但字符常量池、静态变量仍在堆

- 解决 OOM

  - 通过内存印像分析工具对 dump 文件进行分析，确认内存对象是否必要（分清内存泄露或内存溢出）
  - 内存泄露：查看泄露对象到 GC Roots 的引用链，定位泄露代码的位置
  - 不存在内存泄露，即内存中的对象都还必须存活着，就查看虚拟机堆参数，看看内存能否调大，代码上检查周期过长的对象并尝试减少

- 存放内容

  <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第09章_方法区存储内容.jpg" alt="第09章_方法区存储内容" style="zoom: 50%;" />

  <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第09章_方法区存储信息.jpg" alt="第09章_方法区存储信息" style="zoom:33%;" />

  - 类型信息（类 class、接口 interface、枚举 enum、注解 annotation）
    
    > 从概念看，class 相关信息应该在方法区中，但方法区如何实现，java 虚拟机规范没有规定 ，jdk7 及以后的的 HotSpot 选择把**静态变量**与类型在 java 一端的映射 class 对象存放在一起，即存放在堆中
    
    - 该类型有完整有效名称（全名 = 包名.类名）
    - 该类型直接父类的完整有效名称
    - 该类型修饰符（public、abstract、final 的某个子集）
    - 该类型直接接口的一个有序表
    
  - 域（Field）信息
    - JVM 必须在方法区中保存类型所有域相关信息以及域声明顺序
    - 域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）
    
  - 方法信息（必须声明顺序）
    - 方法名称
    - 方法返回类型（或 void）
    - 方法参数数量和类型（按顺序）
    - 方法修饰符（public、private、protected、static、final、synchronize、native、abstract 的某个子集）
    - 方法字节码、操作数栈、局部变量表及大小（abstract 和 native 方法除外）
    - 异常表（abstract 和 native 方法除外），异常处理开始、结束位置，代码处理在程序计数器的偏移地址、被捕获异常类的常量池索引
  
  - non-final 类变量
    
    - 静态变量和类关联在一起，随着类加载而加载，被类所有实例共享，即使没有类实例也可以访问
  
- 运行时常量池

  > 为什么需要常量池：字节码文件需要数据支持，通常这部分数据很大不能直接存到字节码中，可以存到常量池，字节码包含指向常量池的引用（动态链接时使用）
  >
  > 运行时常量池是方法区一部分，常量池是 class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容在类加载后存放到方法区的运行时常量池中
  >
  > 加载类或接口到虚拟机后会创建对应的运行时常量池，jvm 为每个已加载的类或接口都维护一个常量池，池中数据通过索引访问
  >
  > 运行时常量池中不再是常量池中的符号地址，而是真实地址
  >
  > 运行时常量池与常量池相比重要的特征是：具备动态性
  >
  > 如果构造运行时常量池所需空间超过了方法区最大值，jvm 抛出 OOM 异常

  - 常量池

    - 存储的数据类型

      > 数量值
      >
      > 字符串值
      >
      > 类引用
      >
      > 字段引用
      >
      > 方法引用

- 方法区垃圾回收

  > 虚拟机规范没有明说，有些垃圾回收器不支持类卸载

  - 常量池中废弃常量

    > 回收和堆类似
    >
    > 方法区存放两大类常量：

    - 字面量（文本字符串、final 修饰常量值等）
    - 符号引用（类和接口的全限类名；字段、方法的名称和描述符）

  - 不再使用的类型

    > 判定类型是否不再使用
    >
    > 费时

    - 该类所有实例都被回收，即堆中不存在该类及任何派生子类实例
    - 加载该类的类加载器已被回收，该条件较难达成，除非是经过精心设计的可替代类加载器
    - 该类对于 java.lang.Class 对象没有任何引用，无法通过反射访问该类方法

    > 满足以上三个条件就被允许回收，**但不一定被回收**，虚拟机提供 `-Xnoclassgc` 参数进行控制是否进行回收
    >
    > `-verbose:class`、`-XX:+TraceCLass-Loading`、`-XX:+TraceClassUnLoading` 查看类加载和卸载信息
    >
    > 在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 及 OSGi 这类频繁自定义类加载器的场景中，通常需要虚拟机具备类型卸载能力
  
- 直接内存

  > 不是虚拟机的一部分，在 Java 堆外、直接向系统申请的内存
  >
  > 来源于 NIO，通过堆中的 DirectByteBuffer（缓存区）操作 Native 内存
  >
  > <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第09章_直接内存NIO.jpg" alt="第09章_直接内存NIO" style="zoom: 50%;" />
  >
  > 速度通常优于 Java 堆，即读写性能高（频繁使用的场合，NIO 库运行 Java 程序使用直接内存用于数据缓冲区）
  >
  > 有可能导致 OOM 异常，在堆外不受 `-Xmx` 参数指定的最大大小，但系统内存有限，可用 `MaxDirectMemorySize` 设置大小，默认和堆最大值 `-Xmx` 参数一致
  >
  > 缺点：分配回收成本高；不受 JVM 内存回收管理

#### 13、对象的创建

![第10章_对象的实例化](C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第10章_对象的实例化.jpg)

- 对象创建步骤
  - 判断类是否加载、链接、初始化：虚拟机遇到 new 指令，先检查该指令能否在元空间常量池中定位到类的符号引用，并检查该符号引用是否被加载、解析和初始（判断类元信息是否存在），若没有，在双亲委派模式下使用当前类的加载器以 ClassLoader+包名+类名为 Key 查找对应 .class 文件，若没有抛出 ClassNotFoundException 异常，找到就进行类加载并生产对应 Class 对象
  - 为对象分配内存：计算对象占用空间大小，在堆中划分内存给对象，若实例成员变量是引用变量，仅分配引用变量内存（4 个字节）
    - 堆空间内存规整，虚拟机采用**指针碰撞法**来分配：用过的内存在一边，空闲内存在另一边，中间一个指针作为分界点，分配内存即移动指针
    - 内存不规整，采用**空闲列表法**来分配：虚拟机维护一个列表，记录哪些内存块可用，分配时查表获得一块足够大的空间，并更新列表
    - 堆空间规整取决于垃圾收集器是否有压缩整理算法
  - 处理并发安全问题
  - 初始化分配到的空间
  - 设置对象头：将对象所属类（类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁等数据存储在对象的对象头中
  - 执行 init 方法进行初始化：执行实例化代码块，调用类构造方法，吧堆内对象的首地址赋值给引用变量，因此 new 指令后接着是执行方法，进行对象初始化

![第10章_内存布局](C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第10章_内存布局.jpg)

- 内存布局总览

![第10章_图示对象的内存布局](C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第10章_图示对象的内存布局.jpg)

- 对象访问定位

  ![第10章_对象访问定位](C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第10章_对象访问定位.jpg)

  - 句柄访问

    > 缺点：开辟句柄池，浪费空间；效率低
    >
    > 优点：移动对象修改句柄即可

  <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第10章_方式1：句柄访问.jpg" alt="第10章_方式1：句柄访问" style="zoom:33%;" />

  - 直接指针（HotSpot 采用 ）

    <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第10章_方式2：使用直接指针访问.jpg" alt="第10章_方式2：使用直接指针访问" style="zoom:33%;" />

#### 13、执行引擎

> 物理机执行引擎直接建立在处理器、缓存、指令集和操作系统层面上的，虚拟机的是由软件实现的，不受物理条件限制地定制指令集与执行引擎结构体系，能够执行不被硬件直接支持的指令集格式
>
> 作用：将字节码指令解释、编译为对应平台的本地机器指令

- 工作过程

  - 执行什么字节码指令取决于 PC 寄存器
  - 执行完一项指令后 PC 寄存器就会更新下一条指令地址
  - 执行过程中，执行引擎可能通过存储在局部变量表中的对象引用准确定位存储在 Java 堆区中的对象实例信息，以及通过对象头的元数据指针定位目标对象的类型信息

- 程序执行过程（黄色由 javac 编译器完成，java 语言半解释型指绿色，半编译指蓝色）

  > `-Xint` 完全采用解释器
  >
  > `-Xcomp` 完全采用即时编译器
  >
  > `-Xmixed` 采用解释器和即时编译器的混合模式

  - 解释器：当虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台本地机器指令执行

    > 响应速度块

    - 字节码解释器：纯软件代码模拟字节码执行，效率低下
    - 模板解释器：每条字节码和一个模板函数相关联，模板函数直接产生字节码执行时的机器码，很大程度上提高了解释器的性能

  - JIT（Just In Time Compiler）编译器：虚拟机将源代码直接编译成和本地机器平台相关的机器语言

    > 响应速度慢，但编译成机器指令后快
    >
    > `-client` 指定虚拟机运行在 Client 模式下，使用 C1 编译器，C1 对字节码进行简单可靠的优化，耗时短，以达到更快的编译速度
    >
    > `-server` 指定虚拟机运行在 Server 模式下，使用 C2 编译器，C2 进行耗时较长的优化，以及激进优化，优化的代码执行效率高

    <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第12章_程序执行过程.jpg" alt="第12章_程序执行过程" style="zoom:33%;" />

- 编译器

  - 前端编译器：.java 文件转变成 .class 文件

  - 后端运行期编译器（JIT 编译器）：字节码转变为机器码

    - C1 优化策略

      > 方法内联：将引用的函数代码编译到引用点处，减少栈帧生成、参数传递和跳转
      >
      > 去虚拟化：对唯一的实现类进行内联
      >
      > 冗余消除：运行期间吧一些不会执行的代码折叠掉

    - C2 优化策略（主要在全局，基础是逃逸分析）

      > 标量替换：用标量值代替聚合对象的属性值
      >
      > 栈上分配：对未逃逸的对象分配在栈而不是堆
      >
      > 同步消除：清除同步操作，通常指 synchronized

    - 分层编译策略：C1 编译，字节码编译成机器码，简单优化；也可加性能监控，C2 会根据性能监控信息进行激进优化

  - 静态提前编译器（AOT 编译器）：.java 文件编译成机器码

- 热点代码

  > JIT 编译器编译方式也叫做栈上替换（OSR）编译

  - 热点探测：HotSpot 基于计数器的热点探测

    - 方法调用计数器：用于统计方法调用次数

      > 默认 Client 模式 1500 次，Server 模式 1000 次，超过触发 JIT 编译
      >
      > `-XX：CompileThread` 设置阈值
      >
      > 方法调用会先检查是否存在 JIT 编译的版本，存在优先使用，不存在计数器加 1，判断计数器值之和是否超阈值，超时向编译器提交该方法的代码编译请求

      <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第12章_方法调用计数器.jpg" alt="第12章_方法调用计数器" style="zoom: 33%;" />

    - 回边计数器：用于统计循环体执行的循环次数

      <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第12章_回边计数器.jpg" alt="第12章_回边计数器" style="zoom:33%;" />

  - 热度衰减

    > 不做设置，方法调用计数器统计不是方法调用绝对次数，是相对执行频率（一段时间内被调用次数），超过该时间限度时若调用次数不足交给 JIT，该方法调用计数器就会减少一半，这段时间成为该方法统计的半衰周期
    >
    > 热度衰减在虚拟机进行垃圾收集时顺便进行的
    >
    > `-XX:-UseCounterDecay` 关闭热度衰减
    >
    > `-XX:CounterHalfLifeTime` 设置半衰周期的时间，单位秒


#### 14、字符串常量池

> 是一个固定大小的 Hashtable，jdk 6 及之前默认大小 1009，jdk7 改为 60013，jdk8 开始最小可设置长度为 1009，因为放入字符串一多，会造成 Hash 冲突，导致链表很长，影响调用性能
>
> `-XX:StringTableSize` 设置 StringTable 长度

- 字符串拼接操作
  - 常量与常量的拼接结果在常量池，原理是编译期优化
  - 常量池中不会存在相同内容的常量
  - 有一个是变量，拼接结果就在堆中，原理是 StringBuilder（若拼接两者是字符串常量或者常量引用，仍然使用编译期优化，即非 StringBuilder，final 修饰的字符串相当于常量）
  - 若拼接结果使用 `intern()` 方法，主动将常量池中没有的字符串对象放入并返回此对象地址
  
- 保证变量指向字符串常量池的数据

  - `String s = "ss";`
  - `String s = new String("ss").intern();`
  - `StringBuilder s = new StringBuilder("ss").toString().intern();`

- 例题：`new String("a") + new String("b")` 会造 **6** 个对象

  - new StringBuilder
  - new String("a")
  - 常量池中的 ”a“
  - new String("b")
  - 常量池中的 “b”
  - new String("ab")

- 例题：

  ```java
  String s = new String("1");
  s.intern(); //调用该方法前字符串常量池已存在“1”
  String s1 = "1";
  s == s1 //jdk6\7\8: false
      
  String s2 = new String("1") + new String("1"); //执行后字符串常量池不存在“11”
  s2.intern(); //在字符串常量池生成“11”，jdk6 是创建一个新对象“11”，jdk7 是创建指向堆空间 new String("11") 的地址
  String s3 = "11"; //使用字符串常量池中的“11”
  s2 == s3 //jdk6: false jdk7/8: true
  ```

  ![第13章](C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第13章.png)

#### 15、GC

##### （1）算法

> 垃圾：运行程序中没有任何指针指向的对象
>
> GC 主要作用于堆（重点）和方法区：频繁收集 Young 区，较少收集 Old 区，基本不动 Perm 区或元空间

- 垃圾标记阶段

  > 标记已经死亡的对象，GC 时进行回收

  - 引用计数算法

    > 对每个对象保存一个整形的引用计数器属性，用于记录对象被引用的情况
    >
    > 一个对象被引用，该引用计数器加 1，引用失效减 1，为 0 可被回收

    - 优点：实现简单，对象垃圾便于辨识，判定效率高，回收无延迟性

    - 缺点：

      > 需要单独字段存储计数器，增加存储空间开销
      >
      > 每次赋值要更新计数器，加减操作增加时间开销
      >
      > 无法处理循环引用的情况（致命缺陷，java 未选择该算法）

  - 可达性分析算法

    > 解决引用计数算法循环引用问题，放止内存泄露

    - 思路

      > 以根对象集合（GC Roots）为起始点，从上至下搜索被根对象集合所连接的目标对象是否可达
      >
      > 存活的对象都会被根对象集合直接或间接连接，该搜索路径称为引用链
      >
      > 只有能被根对象集合直接或间接连接的对象才是存活对象，若目标对象无任何引用链相连，则不可达，意味该对象死亡，可标记为垃圾对象

    - GC Roots（采用栈方式存放变量和指针，若一个指针保存堆内存里的对象但自己又不存放在堆内存里就是一个 Root）

      > 虚拟机栈中引用的对象，如被调用的方法中使用的参数、局部变量等
      >
      > 本地方法栈内 JNI 引用的对象
      >
      > 方法区中类静态属性引用的对象，如 java 类的引用类型静态变量
      >
      > 方法区常量引用的对象，如字符串常量池里的引用
      >
      > 所有被同步锁 synchronized 持有的对象
      >
      > 虚拟机内部引用，基本数据类型对应的 Class 对象，一些常驻异常对象（NullPointerException、OutOfMemoryException），系统类加载器
      >
      > 反映虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等
      >
      > 除上面固定 GC Roots 集合外，根据用户选用垃圾收集器及当前回收区域不同，可以有其他对象临时加入，如分代收集和局部回收

- finalization（对象终止）机制

  > 垃圾回收一个对象时会先调用该对象的 `finalize()` 方法
  >
  > `finalize()` 方法允许在子类被重写，用于对象被回收时资源的释放，如关闭文件、套接字和数据库连接等

  - 不要主动调用 `finalize()` 方法，应该交给垃圾回收机制调用：
    - 在 `finalize()` 时可能会导致对象复活
    - `finalize()`  方法的执行时间没有保障，完全由 GC 线程决定，若不发生 GC，`finalize()` 方法没有执行机会
    - 一个糟糕的 `finalize()` 会严重影响 GC 性能

- 对象在虚拟机中的三种状态

  - 可触及的：从根节点开始，可以到达该对象
  - 可复活的：对象所有引用被释放，但可能在 `finalize()` 中复活
  - 不可触及的：对象 `finalize()` 被调用，并且没有复活，不可触及对象不可能被复活，因为 `finalize()` 只会调用一次，不可触及对象才能被回收

- 判断对象是否可回收，至少经过两次标记

  - 若对象到 GC Roots 没有引用链，第一次标记
  - 进行筛选，判断对象是否有必要执行 `finalize()` 方法
    - 对象没有重写 `finalize()` 方法，或者 `finalize()` 方法被虚拟机调用过，则判定不可触及
    - 若对象重写 `finalize()` 方法，且还没执行过，对象会被插入到 F-Queue 队列，由虚拟机自动创建的、低优先级的 Finalizer 线程触发其 `finalize()` 方法执行
    - 稍后 GC 会对 F-Queue 队列中的对象进行第二次标记，若对象在 `finalize()` 方法中与引用链上任一对象建立联系，第二次标记时会移出“即将回收集合，之后对象再次出现没有引用存在的情况，由于 `finalize()` 不会再被调用，对象直接变成不可触及状态

- MAT：强大 java 堆内存分析器，用于查找内存泄露以及查看内存消耗情况（jProfiler 也可以查看）

  > 分析 dump 文件，dump 文件可用命令行生成或者 jProfiler 生成

- 清除阶段

  > 速度：复制算法 > 标记-清除算法 > 标记-压缩算法

  - 标记-清除算法

    > 堆有效内存耗尽时，STW，然后：
    >
    > 标记：Collector 从引用根节点开始遍历，标记所有被引用对象（可达对象），一般在对象的 Header（对象头）中记录为可达对象
    >
    > 清除：Collector 对堆内存从头到尾进行线性遍历（所有对象），若发现某个对象其 Header 没有标记为可达对象，将其回收

    - 缺点

      > 效率低（经历两次全遍历）
      >
      > GC 时需要 STW
      >
      > 清理出来的空闲内存不连续，产生内存碎片，需维护一个空闲列表（清除是把垃圾对象保存在空闲的地址列表里，下次有对象加载时，判断垃圾的位置空间是否足够，够就存放）

  - 复制算法

    > 核心思想：将活着的内存空间分成两块，每次只使用其中一块，垃圾回收时将正在使用的内存中的存活对象复制到未使用的内存块中，清除正在使用的内存中的所有对象，交换两个内存角色
    >
    > 应用：from 区和 to 区

    - 优点

      > 没有标记和清除过程，实现简单，运行高效
      >
      > 复制过去以后保证空间连续性，不会出现“碎片”问题

    - 缺点

      > 需要两倍内存空间
      >
      > 对于 G1 这种需要分拆成大量 region 的GC，复制而不是移动，GC 需要维护 region 之间对象引用关系，内存占用或时间开销不小

    - 特别

      > 若系统垃圾对象多，复制算法理想，因为其需要复制的存活对象数量不大

  - 标记-压缩算法

    - 执行过程

      > 第一阶段：和标记-清除算法一致，从根节点开始标记
      >
      > 第二阶段：将所有存活对象压缩到内存一端，按顺序排放，然后清除垃圾对象

    - 优点

      > 消除了标记-清除算法中内存分散缺点，JVM 只需持有一个内存起始地址即可
      >
      > 消除复制算法中内存减半的高额代价

    - 缺点

      > 效率低于复制算法
      >
      > 移动对象时，若对象被其他对象引用，还需要调整引用地址
      >
      > 移动时，要 STW

- 其他算法

  - 分代收集算法

    - 年轻代

      > 适用复制算法，Hotspot 用 survivor 设计缓解复制算法额外内存
      >
      > 特点：对象生命周期短，存活率低，回收频繁

    - 老年代、

      > 适用标记-清除、标记-压缩的混合实现
      >
      > 标记和压缩与存活对象数量成正比
      >
      > 清除与堆内存大小成正比
      >
      > 特点：区域大，对象生命周期长，存活率高，回收不频繁

  - 增量收集算法

    > 思想：若一次性处理所有垃圾，会造成较长的 STW，让垃圾收集线程和应用线程交替运行，每次垃圾线程收集一片区域，接着切回应用线程，反复进行
    >
    > 基础：标记-清除算法和复制算法，对线程冲突妥善处理，允许垃圾收集线程分阶段完成标记、清理和复制

    - 缺点：切换线程和上下文转换的消耗，使垃圾回收总体成本上升，使系统吞吐量下降

  - 分区算法

    > 堆空间越大，GC 时间越长，停顿也越长，将大内存分割成多小块，每次合理回收若干小区间，减少一次 GC 产生的停顿
    >
    > 分代算法按对象生命周期长短分成两部分，分区算法将整个堆空间分成连续不同小区间

    - 缺点：切换线程和上下文转换的消耗，使垃圾回收总体成本上升，使系统吞吐量下降

##### （2）GC 概念

> `System.gc()` 和 `Runtime.getRuntime().gc()` 效果一样，只是建议 JVM 进行垃圾回收
>
> `System.runFinalization()` 强制调用引用对象的 `finalize()` 方法

- 内存溢出 OOM：没有空闲空间，垃圾回收器也无法提供更多内存

  - 原因
    - JVM 堆内存设置不够
    - 代码创建大量大对象且长时间不被垃圾回收器收集
    - 有可能垃圾收集器不被触发：分配一个超大对象，JVM 判断垃圾收集器不能解决，直接抛出 OOM

- 内存泄露：对象不被程序使用，但 GC 不能回收

  - 举例
    - 单例模式：单例生命周期和应用程序一样长，若单例持有外部对象的引用，该外部对象不能回收
    - 提供 close 资源未关闭：数据库连接（dataSource.getConnection()）、网络连接（socket）、io 连接

- stop the world（STW）：GC 时，应用程序停顿

- 并行与并发

  - 并发：一个时间段中有几个程序处于已启动运行到运行完毕之间，且都在同一个处理器上运行（CPU 把一个时间段分成几个时间片，在这几个时间片来回切换，让用户感觉多个应用同时执行）
  - 并行：系统有一个以上 CPU 时（并行多少取决于 CPU 的核心数量），各自执行各自的进程，不抢占 CPU 资源，可同时进行
  - 两者对比：
    - 并发是在同一时间段发生，抢占资源
    - 并行是在同一时间点发生，不抢占资源

- 垃圾回收的并发与并行

  - 并行：多条垃圾收集线程并行工作，用户线程处于等待状态
  - 串行：单线程执行，内存不够则串行暂停启动 JVM 垃圾回收器进行垃圾回收，回收完再启动程序线程

- 安全点与安全区域

  - 安全点（safe point）：程序停顿下来进行 GC 的特定位置

    > 安全点太少导致 GC 等待时间太长，太多可能影响性能
    >
    > 选择标准：执行时间长的指令，如方法调用，循环跳转、异常跳转等
    >
    > 保证线程在最近安全点停顿：

    - 抢先式中断（目前无虚拟机使用）：中断所有线程，若有线程在不安全点就恢复线程，让线程跑到安全点
    - 主动式中断：设置中断标志，各程序运行到安全点时轮询该标志，若中断标志为真则将自己中断挂起

  - 安全区域：若线程处于 sleep 或 blocked 状态无法响应 JVM 中断请求，安全区域是在一段代码中，对象引用关系不发生变化，该区域内任何位置开始 GC 都是安全的

    > 当线程运行到安全区域时，标识进入安全区域，若这段时间发生 GC，JVM 忽略标识为安全区域的线程，线程离开安全区域时会检查 JVM 是否完成 GC，若完成继续运行，否则等到收到可以离开安全区域的信号为止

- 引用
  - 强引用（StrongReference）：最传统，类似`Object o = new Object()` ，**强引用是可触及的*，垃圾回收器不会回收，若没有其他引用关系，只要超过引用作用域或显示将引用赋值为 null 就可以被收集

    - 特点：可以直接访问目标对象，指向的对象不会被回收（虚拟机宁愿抛出 OOM 异常），可能导致内存泄露

  - 软引用（SoftReference）：系统内存即将溢出前，把这些对象列入回收范围之中进行第二次回收，若这次回收还没有足够内存才会抛出内存溢出异常，**软引用是软可触及**

    - 应用：内存敏感的缓存（高速缓存）

    ```java
    SoftReference<Object> o = new SoftReference<>(new Object);
    o.get();	//获取软引用对象
    ```

  - 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前，当垃圾收集器工作时都会回收掉弱引用关联对象，但垃圾回收线程优先级很低，有可能弱引用存在较长时间，**弱引用是弱可触及**

    ```java
    WeakReference<Object> o = new WeakReference<>(new Object);
    ```

    - WeakHashMap：避免 OOM

  - 虚引用（PhantomReference）：对象的虚引用不会对其生存构成影响，无法通过虚引用获得一个对象实例，唯一目的是在对象被收集时收到一个系统通知，必须和引用队列一起使用，当垃圾回收器准备回收一个对象时，若其有虚引用，则回收后将虚引用加入引用队列，以通知应用程序对象回收情况，**虚引用是虚可触及**

     ```java
    ReferenceQueue phantomQueue = new ReferenceQueue();
    PhantomReference<Object> o = new PhantomReference<>(new Object,phantomQueue);
    o.get();	//总是 null
    ```

  - 终结器引用：用以实现对象的 `finalize()` 方法，无需手动编码，其内部配合引用队列使用，GC 时，终结器引用入队，由 Finalizer 线程通过终结器引用找到被引用对象并调用其 `finalize()` 方法，第二次 GC 时才能回收被引用对象

  - 上面引用强度按顺序依次递减

- 垃圾回收器

  - 分类

    - 按线程数

      > 串行垃圾回收器：同一时间段内只有一个 CPU 用于执行垃圾回收操作，工作线程暂停至回收完成，**默认被应用在客户端的 Client 模式下的 JVM 中**
      >
      > 并行垃圾回收器：可以运用多个 CPU 同时执行垃圾回收，提升吞吐量，也需要 STW

    - 按工作模式

      > 并发式垃圾回收器：回收器线程与应用程序线程交替工作，减少程序停顿时间
      >
      > 独占式垃圾回收器：一旦 STW，直到回收结束

    - 按碎片处理

      > 压缩式垃圾回收器（指针碰撞）：回收完对存活对象进行压缩处理
      >
      > 非压缩式垃圾回收器（空闲列表）：不执行压缩操作

    - 按工作内存区间：年轻代垃圾回收器、老年代垃圾回收器

  - 评估指标

    > 吞吐量和暂停时间矛盾：若吞吐量优先，则需要降低内存回收执行效率，导致每次 GC 需要更长的时间；低延迟优先，降低回收暂停时间，只能频繁地回收，使年轻代内存缩减和程序吞吐量下降
    >
    > 目前标准：最大吞吐量时降低停顿时间

    - **吞吐量**：用户代码运行时间占总运行时间比例
    - **暂停时间**：垃圾收集时工作线程被暂停时间
    - **内存占用**：java 堆区占用内存大小

  - 垃圾收集器

    > 最小化使用内存和并行开销：Serial
    >
    > 最大化应用程序的吞吐量：Parallel
    >
    > 最小化 GC 中断或停顿时间：CMS

    - 串行回收器：Serial、Serial Old
    - 并行回收器：ParNew、Parallel Scavenge（jdk8）、Parallel Old
    - 并发回收器：CMS、G1（jdk9）
    - jdk9 移除红线，jdk14 移除绿线和绿框，老年代中 CMS 和 Serial Old GC 是备用的关系

  <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第17章_垃圾收集器组合.jpg" alt="第17章_垃圾收集器组合" style="zoom:33%;" />

  <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第17章_GC对比.png" alt="第17章_GC对比" style="zoom:67%;" />

  - Serial 回收器（串行、单线程、单核 cpu）

    > 用于新生代，最基本最开始的垃圾收集器，作为 Hotspot Client 模式下的默认新生代垃圾收集器
    >
    > 采用复制算法、串行回收和 STW 机制
    >
    > 提供 Serial Old 收集器收集老年代，用标记-压缩算法、串行回收和 STW 机制，是 Client 老年代默认垃圾回收器，在 Server 模式下主要与新生代 Parallel Scavenge 配合或作为老年代 CMS 收集器的后备方案
    >
    > `-XX:+UseSerialGC` 指定年轻代和老年代都使用串行回收器

    - 优势：简单高效（与其他收集器的单线程比），没有线程交互的开销

  - ParNew 回收器（Serial 的多线程版本、多 cpu）

    > 用于新生代，采用并行回收方式，也是采用复制算法、STW 机制
    >
    > 很多 Server 模式下新生代的默认
    >
    > 单 cpu 效率低于 Serial
    >
    > 可以和 CMS 配合使用
    >
    > `-XX:+UseParNewGC` 年轻代指定 ParNew 收集器
    >
    > `-XX:ParallelGCThreads` 限制线程数量，默认开启和 CPU 数据相同线程数

  - Parallel Scavenge 回收器（吞吐量优先）

    > 用于新生代，采用并行回收方式，也是采用复制算法、STW 机制
    >
    > 与 ParNew 不同是达到一个可控的吞吐量，还有自适应调节策略
    >
    > Parallel Old 收集器用于老年代，代替 Serial Old，采用标记-压缩算法。基于并行回收和 STW
    >
    > 在 Server 模式中性能不错，jdk8 的默认回收器

    - 高吞吐量适用后台运算不需要太多交互的任务

    - 参数设置

      > `-XX:+UseParallelGC` 指定年轻代使用 Parallel 回收器
      >
      > `-XX:+UseParallelOldGC` 指定老年代使用并行回收器
      >
      > 以上两个参数，一个开启默认开启另一个（互相激活）
      >
      > `-XX:ParallelGCThreads` 设置年轻代并行收集器线程数，一般和 CPU 数量相等
      >
      > `-XX:MaxGCPauseMillis` 设置垃圾收集器最大停顿时间（STW），单位毫秒，为控制停顿时间，收集器会调整 java 堆大小或其他参数
      >
      > `-XX:GCTimeRatio` 垃圾收集时间占总时间比例，衡量吞吐量，默认 99（垃圾回收时间不超过 1%），与上一参数有矛盾
      >
      > `-XX:+UseAdaptiveSizePolicy` 默认开启，设置 Parallel Scavenge 收集器具有自适应调节策略，该模式下年轻代大小、Eden 和 Survivor 区比例、晋升老年代年龄等参数会被自动调整

  - CMS 回收器（低延迟）

    > 并发，垃圾收集线程和用户线程同时工作
    >
    > 采用标记-清除算法（有内存碎片，不能使用标记-压缩算法因为用户线程还在运行），也会 STW
    >
    > 无法和 Parallel Scavenge 配合，因为底层框架不同，对应新生代只能选择 ParNew 或 Serial

    <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第17章_CMS.png" alt="第17章_CMS" style="zoom: 80%;" />

    - 过程

      > 初始标记阶段：出现 STW，标记出 GC Root 能直接关联的对象，速度快
      >
      > 并发标记阶段：从 GC Roots 的直接关联对象开始遍历整个对象图，耗时长但不需要 STW，用户线程和垃圾回收线程并发运行
      >
      > 重新标记阶段：在并发标记阶段，程序工作线程和垃圾收集线程同时或交叉运行，为了修正并发标记期间用户程序继续运作而导致标记变动的部分对象的标记记录，会 STW，时间比初始标记阶段稍长，比并发标记阶段稍短
      >
      > 并发清除：清理删除掉标记阶段判断死亡的对象，释放内存，不需 STW，和用户线程同时并发
      
    - 注意：在 CMS 回收过程中应保证应用线程用户线程有足够的内存可用，CMS 不能像其他收集器等到老年代几乎填满再收集，而是当堆达到某一使用阈值时开始回收，若运行期预留内存不足，出现 “Concurrent Mode Failure” 失败，启用备用 Serial Old 收集器重新收集老年代，此时停顿时间很长

    - 优点：并发、低延迟

    - 弊端：

      > 产生内存碎片，会提前触发 Full GC
      >
      > 对 CPU 资源很敏感，会因为占用一部分线程导致应用程序变慢，总吞吐量降低
      >
      > 无法处理浮动垃圾，在并发标记阶段如果出现新垃圾无法标记清除

    - 参数

      > `-XX:+UseConcMarkSweepGC` 指定使用 CMS 收集器，开启时会自动开启 ParNew（年轻代）
      >
      > `-XX:+UseCMSCompactAtFullCollection` 指定 Full GC 后对内存空间压缩整理，无法并发，停顿时间变长
      >
      > `-XX:CMSFullGCsBeforeCompaction` 设置多少次 Full GC 后进行内存压缩整理
      >
      > `-XX:ParallelCMSThreads` 设置 CMS 线程数，默认（ParallelGCThreads（年轻代并行收集器线程数）+ 3）/4
      >
      > `-XX:CMSInitiatingOccupanyFraction` 设置堆内存使用率阈值，达到阈值开始回收，jdk5 之前默认为 68，jdk6 后默认为 92，若内存增长缓慢可以设置大点的值降低 CMS 触发率，减少老年代回收次数，反之相反

  - G1 回收器（垃圾优先，区域化分代式）

    > 延迟可控时尽可能提高吞吐量
    >
    > 并行回收器，把堆分割成很多不相关区域（Region，物理不连续），用不同 Region 表示 Eden，幸存者区等等
    >
    > G1 跟踪各 Region 里垃圾价值大小（回收所得空间大小和回收所需时间的经验值），后台维护一个优先列表，每次根据允许回收时间优先回收价值大的 Region
    >
    > 面向服务端，针对多核 CPU 及大容量，是 jdk9 的默认回收器
    >
    > `-XX:UseG1GC` 启用 G1

    - 优势

      > 并行：回收期间可以有多个 GC 线程同时工作
      >
      > 并发：拥有与应用程序交替执行的能力，部分工作和应用程序同时执行，一般不会完全阻塞应用程序
      >
      > 分代收集：不要求 Eden 区、老年代连续和固定大小和数量
      >
      > 同时兼顾年轻代和老年代
      >
      > 空间整合：内存回收以 Region 为基本单位，Region 之间是复制算法，整体可看是标记-压缩算法，避免内存碎片，分配大对象时不会由于空间不足提前 GC
      >
      > 可预测停顿时间模型（软实时）：让用户明确指定一个长度 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒，G1 可以选取部分 Region 进行回收，缩小回收范围，还有优先列表提高收集效率

    - 缺点

      > G1 为垃圾收集产生的内存占用和程序运行时的额外执行负载都高于 CMS
      >
      > 在小内存应用上 CMS 表现大概率优于 G1，而 G1 在大内存有优势

    - 参数

      > `-XX:+UseG1GC` ：指定使用 G1 收集器
      >
      > `-XX:G1HeapRegionSize` ：设置 Region 大小，值是 2 的幂，范围 1-32MB，目标是根据最小堆大小划分大约 2048 个区域，默认为堆的 1/2000
      >
      > `-XX:MaxGCPauseMillis` ：设置期望最大 GC 停顿时间（JVM 尽力但不保证实现），默认 200ms
      >
      > `-XX:ParallelGCThread` ：设置 STW GC 线程数，最多 8
      >
      > `-XX:ConcGCThreads` ：设置并发标记线程数，n 设置为并行垃圾回收线程数的 1/4 左右
      >
      > `-XX:InitiatingHeapOccupancyPercent` ：设置触发并发 GC 周期的堆占用率阈值，超过触发 GC，默认 45

    - 性能调优

      > 开启 G1
      >
      > 设置堆最大内存
      >
      > 设置最大停顿时间

    - 分区：一个 Region 只能属于 Eden、Survivor 等一个区域，回收完就加入空闲列表，Humongous 区域用于存放大对象，超过 1.5 个 Region 就放进去，若一个 H 区放不下会寻找连续的 H 区存放，H 区大多数情况看成老年代

    <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第17章_分区.jpg" alt="第17章_分区" style="zoom: 80%;" />

  - G1 垃圾回收

    - 年轻代 GC：年轻代 Eden 区用尽开始，是并行独占式收集器，STW、创建回收集（Collection Set）、启用多线程回收 Eden 区和 Survivor 区

    > Remember Set：解决对象被不同区引用问题，回收新生代要扫描老年代会降低效率，一个 Region 对应一个 Remember Set，每次 Reference 类型数据写操作时会产生一个 Write Barrier 暂时中断操作，检查写入的引用指向是否和 Reference 在不同 Region，若不同则通过 CardTable 将引用信息记录到指向对象的 Region 的 Remember Set 中，垃圾收集时在 GC 根节点枚举范围加入 Remember Set 就可以保证不进行全局扫描也不会遗漏
    >
    > 过程：
    >
    > - 扫描根
    > - 更新 RSet（处理 dirty card queue 来更新，因为 RSet 处理需要线程同步，用队列性能好）
    > - 处理 RSet
    > - 复制对象（晋升老年代等）
    > - 处理引用（弱强软虚）

    ![第17章_G1集](C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第17章_G1集.jpg)

    - 老年代并发标记（Concurrent Marking）：默认堆使用达到 45% 开始，

    > 过程：
    >
    > - 初始标记阶段：STW，触发一次 YGC
    > - 根区域扫描：扫描 Survivor 区直接可达的老年代区域对象并标记被引用对象，在 YGC 前完成
    > - 并发标记：可能被 YGC 中断，若发现区域对象都是垃圾会立即回收，会计算每个区域对象活性（存活对象比例）
    > - 再次标记：由于应用程序持续进行，需要修正标记结果，STW，采用比 CMS 更快的算法（snapshot-at-the-beginning，SATB）
    > - 独占清理：计算每个区域存活对象和 GC 回收比例，排序识别可混合回收区域，STW，为下阶段做铺垫，不会收集垃圾
    > - 并发清理：识别并清理完全空闲的区域

    - 混合回收（Mixed GC）：从老年代移动存活对象到空闲区间，老年代回收一次只需扫描/回收一小部分 Region，同时连同年轻代一起回收

    > 默认老年代内存分段会分 8 次（`-XX:G1MixedGCCountTarget` 设置），混合回收算法和年轻代一样，只是多了老年代的内存分段
    >
    > 由于老年代分 8 次回收，会优先回收垃圾多的内存分段，有一个阈值决定内存分段是否会被回收，默认 65%，即垃圾占 65%回收
    >
    > 回收到垃圾占堆 10%不再回收（`-XX:G1HeapWastePercent` 设置），不一定进行 8 次

    - Full GC 也存在，针对 GC 评估失败提供的失败保护机制——强力回收

    > 回收时没有足够 to 区存放晋升对象、并发处理完成前内存耗尽

  <img src="C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第17章_G1-GC垃圾回收过程.jpg" alt="第17章_G1-GC垃圾回收过程" style="zoom:33%;" />

  - 新的 GC 回收器

    - Epsilon：无行为，只分配内存，不回收垃圾，适用一次性的程序

    - Shenandoah GC：低延迟，高运行负担下吞吐量下降

    - ZGC（低延迟，jdk14 新特性）

      > 基于 Region 内存布局，暂时不设分代，使用读屏障、染色指针、内存映射等技术实现可并发标记-压缩算法
      >
      > 步骤：并发标记-并发预备重分配-并发重分配-并发重映射
      >
      > 除了初始标记 STW，其余地方都是并发的

- GC 日志

  > 参数：
  >
  > `-XX:+PrintGC` 输出 GC 日志
  >
  > `-XX:+PrintGCDetails` 输出 GC 详细日志
  >
  > `-XX:+printGCTimeStamps` 输出 GC 时间戳（基准时间形式）
  >
  > `-XX:+PrintGCDateStamps` 输出 GC 时间戳（日期形式，2013-05-04）
  >
  > `-XX:+PrintHeapAtGC` 进行 GC 前后打印堆信息
  >
  > `-Xloggc:../logs/gc.log` 日志文件输出目录

  - Young GC

  ![第17章_GC调优分析](C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第17章_YGC调优分析.png)

  - Full GC

  ![第17章_Full GC调优分析](C:\Users\13085\Desktop\git_work\Java\JVM上篇配图\第17章_Full GC调优分析.jpg)

  - 日志分析工具：GCViewer、GCEasy

### 二、字节码与类的加载

P205

### 三、性能监控与调优