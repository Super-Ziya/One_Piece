### 并发

---

#### 1、可重入锁（递归锁）

- 同一线程外层函数获得锁后，再进入该线程的内层方法会自动获取锁 （前提：锁对象是同一个对象）
- Java 中 ReentranLock（显示锁）和 synchronized（隐式锁）都是可重入锁，优点是可在一定程度避免死锁
- 隐式锁（synchronized 关键字使用的锁）：默认是可重入锁（同步块、同步方法）
  - 每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针
  - 执行 monitorenter 时，如果目标锁对象的计数器为零，说明它没有被其他线程持有，Java 虚拟机会将该锁对象的持有线程设置为当前线程，并将其计数器加 1，否则需要等待至持有线程释放该锁
  - 执行 monitorexit 时，Java 虚拟机锁对象的计数器减1，为 0 代表锁已被释放
- 显示锁（lock）：ReentrantLock 是可重入锁，有多少个 lock，就有多少个 unlock

#### 2、LockSupport

- 唤醒线程

  - 使用 Object 的 wait() 方法让线程等待，使用 Object 的 notify() 方法唤醒

    > 在同步块或同步方法里且成对出现使用
    >
    > 先 wait 后 notify
    >
    > synchronized 关键字属于 JVM 层面，monitorenter（底层通过 monitor 对象完成，wait/notify 等方法也依赖 monitor 对象，只能在同步块或方法中调用）

  - 使用 JUC 包中 Condition 的 await() 方法让线程等待，使用 signal() 方法唤醒线程

    > 与上面一样

  - LockSupport 类可阻塞当前线程及唤醒指定被阻塞线程

    - 通过 park() 和 unpark(thread) 方法实现阻塞和唤醒线程
    - LockSupport 是一个线程阻塞工具类，所有方法都是静态方法，可让线程在任意位置阻塞，阻塞后有对应唤醒方法
    - LockSupport 类使用 Permit（许可）实现阻塞和唤醒线程，每个线程有一个许可，permit 只有两个值 1 和 0，默认是 0，可以看成是一种（0,1）信号量(Semaphore）

- LockSupport 阻塞方法

  - permit 默认 0，一开始调用 park() 方法，当前线程阻塞直到别的线程将当前线程的 permit 设置为 1， park 方法被唤醒，然后将 permit 设为 0 并返回
  - static void park()：底层是 unsafe 类 native 方法
  - static void park(Object blocker)
  
- LockSupport 唤醒方法

  - 调用 unpark(thread) 方法会将 thread 线程的许可 permit 设置成 1（多次调用不累加，值为 1)，自动唤醒 thread 线程，即之前阻塞的 LockSupport.park() 方法立即返回

  - static void unpark()

    ```java
    public static void unpark(Thread thread){
        if(thread != null){
            UNSAFE.unpark(thread);
        }
    }
    ```

- LockSupport 解决问题

  - 不持有锁块，不用加锁，程序性能好
  - 先后顺序，不容易导致卡死（unpark 获得一个凭证，之后再调用 park 方法，不会阻塞）

- 例子

  ```java
  public class LockSupportDemo{
      public static void main(String[] args){
          Thread t1 = new Thread(()->{
              System.out.println("t1 coming....");
              LockSupport.park();
              //如果这里有两个LockSupport.park(),因为permit的值为1,上一个已经使用permit,下一个会导致程序处于一直等待的状态
              //LockSupport.park();
              System.out.println("t1 被B唤醒");
          },"A").start();
  
          Thread t2 = new Thread(()->{
              System.out.println("t2 唤醒A线程");
              //如果有两个LockSupport.unpark(t1),由于permit的值最大为1,所以只能给park一个通行证，而调用两次park需要消费两个通行证
              LockSupport.unpark(t1);
              //LockSupport.unpark(t1);
          },"B").start();
      }
  }
  ```

#### 3、JUC

- 工具类（底层用 AQS 实现）

  - CountDownLatch（闭锁）

    - 当一个或多个线程调用 await() 方法时，这些线程会阻塞
    - 其它线程调用 countDown() 方法会将计数器减1（调用 countDown() 方法的线程不会阻塞）
    - 计数器的值为 0 时，因 await() 方法阻塞的线程会被唤醒，继续执行
    - 利用枚举减少 if else 判断

    ```java
    //要求6个线程都执行完,main线程最后执行
    public class CountDownLatchDemo{
        public static void main(String[] args) throws Exception{
            CountDownLatch countDownLatch = new CountDownLatch(6);
            for(int i=1;i<=6;i++){
                new Thread(()->{
                    countDownLatch.countDown();
                },i+"").start();
            }
            countDownLatch.await();
            System.out.println("这是main线程");
        }
    }
    ```

  - CyclicBarrier（可循环 Cyclic 使用的屏障 barrier）

    - 让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时才会开启，所有被屏障拦截的线程继续运行，线程进入屏障通过 CyclicBarrier 的 await() 方法

    ```java
    //集齐7颗龙珠召唤神龙
    public class CyclicBarrierDemo{
        public static void main(String[] args){
            CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->{
                System.out.println("召唤龙珠");
            });
            for(int i=1;i<=7;i++){
                new Thread(()->{
                    System.out.println("收集到第"+i+"颗龙珠");
                    try {
                        cyclicBarrier.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                }).start();
            }
        }
    }
    ```

  - Semaphore（信号量）

    - acquire（获取）： 一个线程调用 acquire 时，要么成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量或超时
    - release（释放）：将信号量的值加 1，唤醒等待的线程
    - 信号量目的：用于多个共享资源的互斥使用、用于并发线程数的控制

    ```java
    public class SemaphoreDemo{
        public static void main(String[] args){
            Semaphore semaphore = new Semaphore(3);
            for(int i=1;i<=6;i++){
                new Thread(()->{
                    try {
                        System.out.println(i+"抢占了车位");
                        semaphore.acquire();
                        System.out.println(i+"离开了车位");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }finally {
                        semaphore.release();
                    }
                },String.valueOf(i)).start();
            }
        }
    }
    ```


#### 4、AQS（AbstractQueuedSynchronizer）

> 通过内置的 CLH（FIFO）队列的变种完成资源获取线程的排队工作，将每条抢占资源的线程封装成一个 Node 节点实现锁分配，有个 int 变量表示持有锁的状态，通过 CAS 完成对 status 值的修改（0 表示没有，1 表示阻塞）

![AQS](C:\Users\13085\Desktop\git_work\Java\图片\AQS.png)

- AQS 框架

  ![AQS框架](C:\Users\13085\Desktop\git_work\Java\图片\AQS框架.png)

- 锁：面向锁的使用者（定义程序员和锁交互的使用层 API，隐藏实现细节）

- 若共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁分配。该机制主要由 CLH 队列的变体实现，将暂时获取不到锁的线程加入队列中，将请求共享资源的线程封装成队列的结点，通过 CAS、自旋及 LockSuport.park() 方式，维护 state 变量的状态，使并发达到同步效果

- 内部体系

  - State 状态：没占用 0，占用 1，大于 1 是可重入锁
  - 若 AB 两个线程进来后，有 3 个 Node 节点，其中队列第一个是傀儡节点（哨兵节点）

  ![AQS体系架构](C:\Users\13085\Desktop\git_work\Java\图片\AQS体系架构.png)

  - ReentrantLock

    - 公平锁：多个线程按照申请顺序获得锁，线程直接进入队列排队，队列第一位才能得到锁

      > 优点：所有线程都能得到资源，不会饿死在队列中
      >
      > 缺点：吞吐量下降，队列里除第一个线程，其他线程都阻塞，cpu 唤醒阻塞线程开销很大

    - 非公平锁：多个线程获取锁时直接尝试获取，获取不到再进入等待队列，能获取到就直接获取到锁
      > 优点：减少 CPU 唤醒线程开销，整体吞吐效率高点，CPU 不必取唤醒所有线程，减少唤起线程的数量
      >
      > 缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死

    - 公平锁与非公平锁的 lock() 方法唯一的区别：公平锁在获取同步状态时多一个限制条件 hasQueuedPredecessors()，用于判断等待队列中是否存在有效节点

#### 5、进程/线程间同步机制

- 线程中
  - 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占

  - 互斥量：采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享（可以命名），比临界区复杂

  - 信号量：允许多线程在同一时刻访问同一资源，但需限制在同一时刻访问此资源的最大线程数目。与前面几种不同，与操作系统中 PV 操作相同

    - 信号量 S 是一个整数，大于等于 0 代表可供并发进程使用的资源实体数，小于 0 时表示正在等待使用共享资源的进程数

      > PV 操作：
      >
      > P 操作申请资源：
      >
      > - S 减 1；
      > - 若 S 仍大于等于 0，进程继续执行；
      > - 若 S 小于 0，该进程被阻塞后进入与该信号相对应的队列中，转入进程调度
      >
      > V 操作释放资源：
      >
      > - S 加 1；
      > - 若结果大于 0，进程继续执行；
      > - 若结果小于等于 0，从该信号的等待队列中唤醒一个等待进程，返回原进程继续执行或转入进程调度

  - 事件：通过通知操作的方式保持线程的同步，方便实现对多个线程的优先级比较的操作

- 进程

  - 管道：有命名管道和非命名管道（匿名管道），非命名管道只能用于父子进程通讯，命名管道可用于非父子进程，命名管道是 FIFO，管道是先进先出的通讯方式

    > 管道：速度慢，容量有限，只有父子进程能通讯   
    >
    > FIFO：任何进程间都能通讯，速度慢

  - 消息队列：用于两个进程间的通讯，先在一个进程中创建一个消息队列，然后往消息队列中写数据，另一个进程从消息队列中取数据。消息队列用创建文件的方式建立，如果一个进程向某个消息队列中写入了数据后，另一个进程没有取出数据，即使向消息队列写数据的进程已经结束，保存在消息队列中的数据没有消失

  - 信号量：与 WINDOWS 的信号量一样

    > 不能传递复杂消息，只能用来同步

  - 共享内存：类似 WINDOWS 的 DLL 的共享变量，LINUX 下的共享内存区不需像 DLL 这样，只要先创建一个共享内存区，其它进程按一定步骤就能访问这个共享内存区中的数据，可读可写

    > 容易控制容量，速度快，但要保持同步