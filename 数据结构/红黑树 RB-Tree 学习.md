### 红黑树 RB-Tree

#### （1）红黑树性质

- 结点分为红色和黑色两种
- 根节点是黑色的
- 每个叶子结点（nil）是黑色的（null 代表黑色）
- 不存在父子都是红色的情况（连续两个红色）
- 任意孩子到根节点的路径上的黑色数量都相等

#### （2）插入

> 插入黑色结点除非在根节点，否则一定会导致一个分支上所有子分支都多了一个黑节点，不满足性质 5，所以插入节点是红色，插入方式是普通二叉排序树的插入方式

- 情况一：单节点，无父节点：红色变成黑色，性质2

- 情况二：父节点黑色：不用修改

- 情况三：父节点红色

  - N 的叔父节点 U 为红色：将 N 的父节点 P 和叔父节点 U 都改为黑色，若祖父节点 G 是根节点就改为黑色，否则改为红色，以祖父节点 G 为插入的目标节点从情况 1 开始递归检测

  ![红黑树_插入父红](C:\Users\13085\Desktop\One_Piece\数据结构\图片\红黑树_插入父红.png)

  - N 的叔父节点 U 为黑色，且 N 和父节点 P 在同一边：以父节点 P 为祖父节点 G 的左儿子为例，将父节点 P 改为黑色，祖父节点 G 改为红色，以祖父节点 G 为基准右旋（父节点 P 右儿子做相应左旋）

  ![红黑树_插入父黑同边](C:\Users\13085\Desktop\One_Piece\数据结构\图片\红黑树_插入父黑同边.png)

  - N 的叔父节点 U 为黑色，且 N 和父节点 P 不在同一边：以父节点 P 为祖父节点 G 的左儿子为例，以父节点 P 为基准左旋，以父节点 P 为目标插入节点进入情况 3 操作

  ![红黑树_插入父黑不同边](C:\Users\13085\Desktop\One_Piece\数据结构\图片\红黑树_插入父黑不同边.png)

#### （3）删除

- 情况一：红色节点：直接删除，用黑色儿子代替其位置

- 情况二：黑色节点，父节点红色：直接删除，用子节点代替其位置，该子节点改为黑色

- 情况三：黑色节点，父节点黑色：直接删除，用子节点代替其位置，该子节点改为黑色，作为当前节点 N`

  - N`的兄弟节点 S 及其儿子都是黑色：交换兄弟节点 S 和父节点 P 颜色

  ![红黑树_删除兄及其儿黑](C:\Users\13085\Desktop\One_Piece\数据结构\图片\红黑树_删除兄及其儿黑.png)

  - N`的兄弟节点 S 为黑色、且其红色儿子和兄弟节点 S 同边：以兄弟节点 S 为右儿子为例，将父节点 P 和兄弟节点 S 颜色互换，将红色儿子的改为黑色，以父节点 P 为基准左旋（兄弟节点 S 为左儿子相应右旋）

  ![红黑树_删除兄黑其儿红同边](C:\Users\13085\Desktop\One_Piece\数据结构\图片\红黑树_删除兄黑其儿红同边.png)

  - N\`的兄弟节点 S 为黑色、且其红色儿子和兄弟节点 S 不同边：以兄弟结点 S 为右儿子为例，将兄弟节点和其红色儿子颜色互换，以兄弟节点 S 为基准右旋，对 N\` 来说进入情况三第二种情况（兄弟节点 S 为右儿子相应左旋）

  ![红黑树_删除兄黑其儿红不同边](C:\Users\13085\Desktop\One_Piece\数据结构\图片\红黑树_删除兄黑其儿红不同边.png)

  - N\`的兄弟节点 S 为红色：以兄弟节点 S 为右儿子为例，将父节点 P 和兄弟节点 S 颜色互换，以父节点 P 为基准左旋（兄弟节点 S 为左儿子相应右旋），N\`有一个黑色兄弟节点，进入情况三前三种情况操作

  ![红黑树_删除兄红](C:\Users\13085\Desktop\One_Piece\数据结构\图片\红黑树_删除兄红.png)

  - N`的兄弟节点 S 为黑色，父节点 P 黑色：将兄弟节点 S 改为红色，以父节点 P 为目标插入节点从头开始依次判断

  ![红黑树_删除兄黑父黑](C:\Users\13085\Desktop\One_Piece\数据结构\图片\红黑树_删除兄黑父黑.png)

#### （4）红黑树和 AVL 比较优缺点

> 和 AVL 树一样都是 BBST（Balance Binary Search Tree，平衡二叉搜索树）

- 红黑树不追求"完全平衡"，不像 AVL 要求节点的 `|balFact| <= 1`，只要求部分平衡，为节点增加颜色，用非严格平衡换取增删节点时旋转次数的降低，任何不平衡都会在三次旋转之内解决，AVL 是严格平衡树，在增加或删除节点时旋转次数比红黑树多

- 插入节点导致失衡，AVL 和 RB-Tree 都是最多两次旋转实现复衡，旋转量级 O(1)
- 删除节点导致失衡，AVL 需维护从被删节点到根节点 root 这条路径上所有节点的平衡，旋转量级为 O(logN)，RB-Tree 最多只需要旋转 3 次实现复衡 O(1)，RB-Tree 删除节点的复衡效率更高，开销更小
- AVL 结构较于 RB-Tree 更平衡，搜索效率更高
- 针对插入、删除节点导致失衡后的复衡操作，红黑树是对搜索、添加、删除效率的折衷，总体来说统计性能高于 AVL
- AVL 更平衡，结构上更直观，时间效率：读取快、维护稍慢、空间开销较大
- 红黑树，读取略慢于 AVL，维护强于 AVL，空间开销与 AVL 类似，内容极多时略优于 AVL，维护优于 AVL