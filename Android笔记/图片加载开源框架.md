### 图片加载开源框架

- 为什么选择开源项目：快速开发、站在巨人的肩膀上

- 选择开源项目注意：Star、Issues、产出者、文档详细度、原理、业务场景

- 四大框架

  |                |   ImageLoader    |      Picasso       |       Glide       |  Fresco  |
  | :------------: | :--------------: | :----------------: | :---------------: | :------: |
  |      作者      | nostra13（大牛） | Square（国际知名） | Sam sjudd（谷歌） | Facebook |
  |      时间      |     2011/09      |      2013/02       |      2012/12      | 2015/03  |
  |  Star/Issues   |      16/439      |       16/159       |      25/125       |  15/75   |
  |      gif       |        F         |         F          |         T         |    T     |
  |      webp      |        F         |         T          |         T         |    T     |
  |   视频缩略图   |        F         |         F          |         T         |    T     |
  |      大小      |       159k       |        100k        |       500k        |   2-3m   |
  |    加载速度    |        中        |         中         |        高         |    高    |
  | disk+mem cache |        T         |         T          |         T         |    T     |

- 框架组成

  - RequestManager：请求生成和管理模块
  - Engine：引擎部分，负责创建任务(获取数据)，并调度执行
  - GetDatalnterface：数据获取接口，负责从各个数据源获取数据（3级缓存、缩略图等）
  - Displayer：资源(图片)显示器，用于显示或操作资源（显示在哪一个布局等）
  - Processor：资源(图片)处理器（灰度处理、圆角、裁剪等）

- 图片加载需求

  - 异步加载（线程池）
  - 线程切换（Handler）
  - 防止OOM：软引用、LruCache、图片压缩、Bitmap存储位置
  - 内存泄露：ImageView引用、生命周期管理（LifeCycle）
  - 三级缓存（LruCache、DiskLruCache）
  - 支持占位图片加载（图片还没加载、加载失败）
  - 列表滑动加载的问题：加载错乱（给ImageView设置tag）、队满任务过多问题

- 技术点

  - 生产者、消费者、建造者模式
  - 单例模式、模板方法模式、策略模式
  - 内存缓存LruCache技术
  - 磁盘缓存DiskLruCache技术

- ImageLoader

  - 支持下载进度监听
  - 可以在View滚动中暂停图片加载
  - 默认实现多种内存缓存算法
  - 支持本地缓存文件名规则定义

  <img src="C:\Users\13085\AppData\Roaming\Typora\typora-user-images\image-20210701213600692.png" alt="image-20210701213600692" style="zoom: 80%;" />

- Picasso

  - 自带统计监控功能（测试性能）
  - 支持优先级处理
  - 支持延迟到图片尺寸计算完成加载
  - 支持飞行模式、并发线程数根据网络类型而变

  <img src="C:\Users\13085\AppData\Roaming\Typora\typora-user-images\image-20210701214119628.png" alt="image-20210701214119628" style="zoom:80%;" />

- Glide：默认RGB-565（比888小一倍）

  <img src="C:\Users\13085\AppData\Roaming\Typora\typora-user-images\image-20210701214947319.png" alt="image-20210701214947319" style="zoom:80%;" />

  - 特点

    - 图片缓存 -- 媒体缓存
    - 支持优先级处理
    - 与Activity/Fragment生命周期—致（使用LifeCycle框架实现），支持trimMemory（内存警告时可以主动释放）
    - 支持okhttp、Volley
    - 内存友好（两级缓存，可以缓存优化好的更小的图片）

  - 使用：`Glide.with(this).load(URL).into(image)`

    - `Glide.with(this)`，生命周期

      > 判断是否在子线程，子线程就直接进行，主线程就添加空白Fragment，监听生命周期，所以Glide不会在子线程中with，子线程不会添加生命周期
      >
      > 最终返回RequestManager对象

      ![image-20210702115450380](C:\Users\13085\AppData\Roaming\Typora\typora-user-images\image-20210702115450380.png)

      > with有很多重载方法，对应不同的作用域
      >
      > 一个Activity对应一个空白的SupportRequestManagerFragment，对应一个RequestManager

      ![image-20210702143847801](C:\Users\13085\AppData\Roaming\Typora\typora-user-images\image-20210702143847801.png)

    - RequestManager.load(URL) 返回RequestBuilder，构建对象，URL处理保存

    - RequestBuilder.into(image) 返回ImageViewTarget，缓存机制，Http网络，解码，压缩

      > RequestBuilder的requestOptions检测布局文件的scaleType并设置，使用原型设计模式
      >
      > 构建请求，如果上个请求未完成先处理上个请求

      ![image-20210702112254844](C:\Users\13085\AppData\Roaming\Typora\typora-user-images\image-20210702112254844.png)

      > 总结图

      ![img](https://upload-images.jianshu.io/upload_images/5982616-01e05ccac5af0720.png)

      > `RequestBuilder.into`
      >
      > ​	BaseRequestOptions（检测布局中scaleType参数，原型设计模式）
      >
      > ​	构建请求Request，得到SingleRequest，如果上个请求没完成，先执行上个请求，每次请求	前先RequestManager.clear
      >
      > -- `RequestManager.track` -- runRequest（Set requests List：运行队列，pendingRequests：等待队列）
      >
      > -- `SingleRequest.begin`（加锁，如果正在运行抛出异常，测量图片的宽高）-- onSizeReady
      >
      > -- `Engine.load`（创建key（工厂设计模式），获取对应图片）-- loadFromMemory（先从活动缓存拿（面向用户，回收时保存到内存缓存）、再从内存缓存拿（面向活动缓存），都是运行时缓存）
      >
      > ​	活动缓存 -- 内存缓存 -- `jobs.get` 磁盘缓存 -- 网络
      >
      > ​	EngineJob 包含大量线程池，用来执行请求
      >
      > ​	DecodeJob Runable，交给EngineJob执行 -- run -- runWrapped（判断有无配置缓存策略）
      >
      > -- `SourceGenerator.startNext` 
      >
      > Glide面向组件，在构建时注册：`append(GlideUrl.class,InputStream.class,new HttpGlideUrlLoader.Factory())` ，GlideUrl对应Url，作为key得到资源
      >
      > -- `HttpGlideUrlLoader.buildLoadData` 
      >
      > -- `new HttpUrlFetcher`（网络请求，HttpURLConnection是应用层对socket的封装，内部继承了OkHttp，得到InputStream后进行回调采样压缩）
      >
      > -- `DataCacheGenerator.onDataReady` 
      >
      > -- `DecodeJob.onDataFetcherReady` -- runLoadPath
      >
      > -- `LoadPath.load`
      >
      > -- `DecodePath.decode`（根据图片宽高、scaleType解码）
      >
      > -- `StreamBitmapDecoder.decode`（真正解码，采样压缩，返回Bitmap）
      >
      > -- 再优化
      >
      > -- `EngineJob.OnResourceReady`
      >
      > -- `Engine.loadFromActiveResources`（保存到活动中，弱引用）
      >
      > -- `SingleRequest.onResourceReady` -- `target.onResourceReady`
      >
      > -- `ImageViewTarget.setResourceInternal`
      >
      > -- `DrawableImageViewTarget（ImageViewTarget的子类）.setResource` -- view.setImageDrawable（展示图片）

  - 缓存策略

    > 先从弱引用中取对象，如果存在，引用计数+1，如果不存在，从 LruCache 取，如果存在，引用计数+1，并把它存到弱引用中，且自身从 LruCache 移除
    >
    > 内存缓存防止应用重复将图片数据读取到内存中，硬盘缓存防止应用重复从网络或其他地方下载和读取数据

    - DiskCacheStrategy.NONE：不缓存文件
    - DiskCacheStrategy.SOURCE：只缓存原图
    - DiskCacheStrategy.RESULT：只缓存最终加载的图（默认）
    - DiskCacheStrategy.ALL：同时缓存原图和结果图

    |     缓存类型      |      缓存代表       | 说明                                                         |
    | :---------------: | :-----------------: | ------------------------------------------------------------ |
    |     活动缓存      |   ActiveResources   | 如果当前对应的图片资源是从内存缓存中获取的，那么会将这个图片存储到活动资源中。 |
    |     内存缓存      |  LruResourceCache   | 图片解析完成并最近被加载过，则放入内存中                     |
    | 磁盘缓存-资源类型 | DiskLruCacheWrapper | 被解码后的图片写入磁盘文件中                                 |
    | 磁盘缓存-原始数据 | DiskLruCacheWrapper | 网络请求成功后将原始数据在磁盘中缓存                         |

    - 缓存key：根据 url、签名，宽高等，其内部重写了 hashCode，equals，来保证对象的唯一性

  - 四层缓存

    - 活动资源：当需要加载某张图片能够从内存缓存中获得的时候，在图片加载时主动将对应图片从内存缓存中移除，加入到活动资源中。 可以避免因达到内存缓存最大值或者系统内存压力导致的内存缓存清理，释放掉活动资源中的图片(recycle)。 活动资源中是一个”引用计数"的图片资源的弱引用集合。因为同一张图片可能在多个地方被同时使用，每一次使用都会将引用计数+1，而当引用计数为0时，表示图片没有被使用，会将图片从活动资源中移除，加入内存缓存

    - 内存缓存：内存缓存默认使用LRU(最近最少使用算法)，当资源从活动资源移除时，会加入此缓存。使用图片时候主动从此缓存移除，加入活动资源。

    - 磁盘缓存：

      > Resource 缓存经过解码后的图片，如果再使用就不需要再去进行解码配置(BitmapFactory.Options)，加快获得图片速度。如原图100x100的ARGB_8888图片，首次使用时需要50x50的RGB_565图片，Resource将50x50 RGB_565缓存下来，再次使用此图片时就可以从 Resource 获得。不需要去计算inSampleSize(缩放因子)
      >
      > Data 缓存的则是图像原始数据

    - Bitmap复用：如果缓存都不存在，从源地址获得图片(网络/文件)。而在解析图片的时候可以获得BitmapPool(复用池)，达到复用的效果。未使用复用，每张图片都需要一块内存。使用复用时，如果存在能被复用的图片会重复使用该图片的内存。 复用不能减少程序正在使用的内存大小，解决的是减少频繁申请内存带来的性能(抖动、碎片)问题

  - 线程池

    ```java
    private GlideExecutor sourceExecutor;	 //加载源文件的线程池，包括网络加载
    private GlideExecutor diskCacheExecutor; //加载硬盘缓存的线程池
    private GlideExecutor animationExecutor; //动画线程池
    ```

- Fresco

  Glide使用的onLowMemory防止OOM

  - 最大优势是内存管理（安卓5.0以前缓存在匿名共享内存）
  
    - Android 8.0后Bitmap像素内存放在native堆，Bitmap导致OOM的问题基本不会在8.0以上设备出现了（没有内存泄漏的情况下）
  
    > Bitmap创建通过native方法 `nativeCreate`
      >
      > JNI动态注册，nativeCreate 方法 对应 `Bitmap_creator` 
      >
      > 申请内存：创建native层Bitmap，通过c++的 `calloc` 函数申请一块内存空间，然后创建native层Bitmap对象，把内存地址传过去
      >
      > 创建java 层Bitmap：通过JNI创建Java层Bitmap对象，这个对象在java堆中分配内存
  
    - 8.0前Bitmap像素数据是放在java堆
  
      > native层Bitmap 创建通过 `GraphicsJNI::allocateJavaPixelRef`，计算需要的空间大小，通过JNI在java层创建一个数组
      >
      > 获取创建的数组的地址，创建Bitmap，传该地址
      >
      > 回收由GC完成，6.0以前，Bitmap 通过finalize 方法释放native层对象，在Bitmap构造方法创建了一个 `BitmapFinalizer`类，重写finalize方法，在java层Bitmap被回收的时候，BitmapFinalizer 对象也会被回收，finalize方法肯定会被调用，在里面释放native层Bitmap对象
  
    - 3.0以下Bitmap像素内存放在native堆，但是需要手动释放native层的Bitmap，也就是需要手动调用recycle方法，native层内存才会被回收
  
  - 大大减少OOM
  
  - 专业的图片处理库
  
  - 包较大，用法复杂，设计c++领域，阅读源码深入学习成本高
  
  <img src="C:\Users\13085\AppData\Roaming\Typora\typora-user-images\image-20210701215937662.png" alt="image-20210701215937662" style="zoom:80%;" />
