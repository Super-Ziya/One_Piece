## 第一行代码学习笔记

###一、Android简介

####1、系统框架

（1）Linux内核层

> 为硬件提供底层驱动，如显示驱动、Wi-Fi驱动、电源管理等等

（2）系统运行库层

> ​	C/C++库为系统提供主要的特性支持，如SQLite库提供数据库支持、OpenGL|ES提供3D绘图支持、Webkit库提供浏览器内核支持等。
>
> ​	这一层有Android 运行时库，允许使用Java开发，还包含了Dalvik虚拟机（5.0后改为ART运行环境），使得每个应用都能运行在独立进程中，并拥有自己的Dalvik虚拟机实例。相较于Java虚拟机，Dalvik专门为移动设备定制的，针对内存、CPU性能有限的情况做了优化处理。

（3）应用框架层

> 提供构建应用时可能用到的API

（4）应用层

> 应用程序

####2、四大组件

活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、内容提供器（Content Provider）

#### 3、目录结构

- .gradle 和 .idea：放置Android Studio自动生成的一些文件

- app：放置项目的资源、代码

- build：编译时自动生成的文件

- gradle：包含gradle wrapper的配置文件

- gitignore：指定目录或文件的版本控制

- build.gradle：全局gradle配置文件

> `jcenter()` 代码托管仓库，可以使用jcenter上的开源项目
>
> ```java
> repositories {
>     jcenter()
> }
> ```
>
> 用Gradle构建Android项目，在dependencies闭包中声明一个Gradle插件
>
> ```Java
> dependencies {
>     classpath 'com.android.tools.build:gradle:3.5.4'
> }
> ```

- gradlew 和 gradlew.bat：用来在命令行窗口执行gradle命令，前者用于Linux系统，后者Windows系统

- .iml ：标识IntelliJ IDEA项目（Android Studio是基于IntelliJ IDEA开发的）

- local.properties：指定本机SDK路径

- setting.gradle：指定项目中所有引入的模块

#### 4、app目录结构

- build：包含编译生成文件

- libs：存放第三方jar包

- androidTest ：编写Android Test测试用例

- java：放置Java代码

- res：drawable放置图片；layout放置布局；values放置字符串、样式、颜色配置；mipmap放置应用图标

- AndroidManifest.xml：整个项目配置文件，四大组件在此注册，添加权限

> `android:icon` 应用图标设定
>
> `android:lable` 应用名称设定

- test：编写Unit Test测试用例

- .gitignore：指定目录或文件的版本控制

- app.iml：IntelliJ IDEA项目自动生成文件

- build.gradle：app的gradle构建脚本，指定项目构建相关配置

> apply plugin：有 ` 'com.android.application'` 和`'com.android.library'` 两个值，前者表示应用程序模块，后者表示库模块，库模块只能作为代码库依赖其他程序模块运行
>
> - android闭包：
>
> > compileSdkVersion：用于指定项目编译版本
> >
> > buildToolsVersion：用于指定项目构建工具版本
> >
> > - defaultConfig 闭包：
> >
> > > applicationId：指定项目包名
> > >
> > > targetSdkVersion：指定目标版本，系统为应用启用新功能和特性
> > >
> > > versionCode：指定项目版本号
> > >
> > > versionName：指定项目版本名
> >
> > - buildTypes闭包：通常只有debug和release两个子闭包
> >
> > > minifyEnabled：混淆项目代码（true混淆）
> > >
> > > proguardFiles：指定混淆规则文件
>
> - dependencies闭包：本地依赖、库依赖、远程依赖

- proguard-rules.pro：指定混淆规则

#### 5、日志工具Log

优先级：

v（verbose）、d（debug）、i（info）、w（warn）、e（error）

### 二、活动Activity

####1、主活动注册

```java
<intent-filter>
    <action android:name="android.intent.action.MAIN" />
    <category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
```

#### 2、活动基本介绍

- AppCompatActivity：向下兼容的Activity，最低兼容到2.1系统，是Activity的子类

-  `setContentView()` 给当前活动引入布局

-  `finish()` 销毁活动

#### 3、menu菜单

```xml
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:id="@+id/add_item"
        android:title="Add"/>
    <item
        android:id="@+id/remove_item"
        android:title="Remove"/>
</menu>
```

`android:title` 为菜单项指定名称

```java
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
}
```

true表示显示菜单，false不显示

```java
@Override
public boolean onOptionsItemSelected(@NonNull MenuItem item) {
    switch (item.getItemId()){
        case R.id.add_item:
            Toast.makeText(this,"you clicked add",Toast.LENGTH_SHORT).show();
            break;
        case R.id.remove_item:
            Toast.makeText(this,"you clicked remove",Toast.LENGTH_SHORT).show();
            break;
        default:
    }
    return true;
}
```

#### 4、显示Intent

```java
Intent intent = new Intent(MainActivity.this, EditTextActivity.class);
startActivity(intent);
```

#### 5、隐式Intent

```java
Intent intent = new Intent(com.hzy.helloworld.ACTION_START);
intent.addCategory("android.intent.category.DEFAULT");
startActivity(intent);
```

- 只有<action>和<category>中的内容同时能够匹配Intent中指定的action和category时才能响应该Intent

- `android.intent.category.DEFAULT` 是一种默认的category

- 一个Intent只能指定一个action，但可以指定多个category

```java
Intent intent = new Intent(com.hzy.helloworld.ACTION_VIEW);
intent.setDate(Uri.parse("http://www.baidu.com"));
startActivity(intent);
```

用隐式Intent启动其他程序（浏览器）

在<intent-filter>标签中可以再添加一个<data>标签：

> android:scheme 指定数据协议，如上例http
>
> android:host 指定数据主机名，如上www.baidu.com
>
> android:port 指定数据端口
>
> android:path 指定主机名和端口之后的内容
>
> android:mimeType 指定可以处理的数据类型，一般用通配符的方式

当<data>标签中的内容和Intent中携带data完全一致时，该活动才可以响应该Intent

#### 6、活动间传递数据

```java
Intent intent = new Intent(MainActivity.this, EditTextActivity.class);
intent.putExtra("extra_data","data");//接收两个参数，一个是键，一个是真正的数据
startActivity(intent);
```

取出数据：

```java
Intent intent = getIntent();
String data = intent.getStringExtra("extra_data");//如果是int类型则getIntExtra方法，以此类推
```

返回数据给上个活动：

```java
Intent intent = getIntent();
intent.putExtra("extra_data","data");
setResult(RESULT_OK,intent);//一般第一个参数只用RESULT_OK和RESULT_CANCELED
```

接收下个活动的数据：

```java
Intent intent = new Intent(MainActivity.this, EditTextActivity.class);
startActivityForResult(intent,1);//请求码需要唯一值（1）

 @Override
protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
    switch (requestCode){
        case 1:
            if (resultCode == RESULT_OK){
                String returnedData = data.getStringExtra("data_return");
                Log.d("FirstActivity",returnedData);
            }break;
        default:
    }
}
```

如果是按下返回键回传数据，只需要重写onBackPressed()方法即可

#### 7、活动生命周期

Android使用任务（Task）来管理活动，一个任务就是一组存放在栈（返回栈Back Stack）里的活动集合

- 活动状态：

> 运行状态：活动处于栈顶
>
> 暂停状态：活动不处于栈顶，但仍然可见
>
> 停止状态：不处于栈顶，完全不可见，有可能被系统回收
>
> 销毁状态：活动从栈移除

- 活动生存期

> onCreate() 活动第一次创建时调用，完成初始化操作（加载布局，绑定事件）
>
> onStart() 活动由不可见变为可见时调用
>
> onResume() 活动准备好和用户交互时调用，此时活动处于栈顶，处于运行状态
>
> onPause() 系统准备恢复活动时调用，这个方法执行速度要快
>
> onStop() 活动完全不可见时调用
>
> onDestroy() 活动被销毁之前调用
>
> onRestart() 活动由停止状态变为运行状态时调用，活动被重新启动

如果新活动是一个对话框式活动，onPause()会得到执行，而onStop()不会

<img src="Image.assets\ActivityLifeCycle.jpg" alt="ActivityLifeCycle" style="zoom: 20%;" />

- 活动回调

```java
@Override
public void onSaveInstanceState(@NonNull Bundle outState, @NonNull PersistableBundle outPersistentState) {
    super.onSaveInstanceState(outState, outPersistentState);
    String tempData = "data";
    outState.putString("data_key",tempData);//putInt保存整形，以此类推
}
```

onSaveInstanceState方法可以保证活动被回收之前一定被调用

恢复数据：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
	super.onCreate(savedInstanceState);
	setContentView(R.layout.activity_main);
	if (savedInstanceState != null){
		String tempData = savedInstanceState.getString("data_key");
	}
}
```

使用Bundle来传递数据

#### 8、活动的启动模式

在AndroidManifest.xml中给<activity>标签指定android:launchMode属性来选择启动模式

- standard 系统默认的启动模式，有新活动就会在返回栈中入栈，每次启动都会创建一个实例
- singleTop 如果活动在栈顶，则直接使用，不会再创建新实例，这种启动模式通常适用于接收到消息后显示的界面，例如QQ接收到消息后弹出 Activity，如果一次 10 条消息，不能一次弹 10 个 Activity，这种启动模式系统仍会在 Activity 启动时调 `onNewIntent()` 方法
- singleTask 每次启动活动会先检查返回栈中是否有该活动的实例，存在则将该 Activity 置于栈顶，并将该 Activity 以上的 Activity 都销毁。如果其他程序以 singleTask 模式启动该 Activity，则将创建一个新任务栈。如果启动模式为 singleTask 的 Activity 已在后台一个任务栈中，则启动后，后台该任务栈将一起被切换到前台，这种启动模式可用来退出整个应用：主 Activity 设为 singleTask 模式，在要退出的 Activity 中转到主Activity，将主 Activity 之上的 Activity 都清除，重写主 Activity 的 `onNewIntent()` 方法，加上一句 `finish()` ，将最后一个 Activity 结束掉

<img src="Image.assets\singleTask.jpg" alt="singleTask" style="zoom:67%;" />

- singleInstance 活动启用新的返回栈管理该活动（singleTask指定不同的taskAffinity也可以实现），如果应用 A 的任务栈中创建 MainActivity 实例，启动模式为singleInstance，如果应用 B 也要激活 MainActivity，则不需创建，两个应用共享该实例。这种启动模式常用于需要与程序分离的界面，如在 SetupWizard 中调用紧急呼叫。
  如果在一个 singleTop 或者 singleInstance 的 ActivityA 中通过 `startActivityForResult()` 方法启动另一个 ActivityB，系统将直接返回 `Activity.RESULT_CANCELED` 而不会等待返回。因为系统在 Framework 层做了对这两种启动模式的限制，Android 开发者认为不同 Task 之间，默认不能传递数据，只能通过Intent 来绑定数据

####9、灵活退出程序

新建一个ActivityCollector集合类对所有活动进行管理

```Java
public class ActivityCollector {
    public static List<Activity> sActivityList = new ArrayList<>();

    public static void addActivity(Activity activity){
        sActivityList.add(activity);
    }
    
    public static void removeActivity(Activity activity){
        sActivityList.remove(activity);
    }
    
    public static void finishAll(){
        for (Activity activity : sActivityList){
            if (!activity.isFinishing()){
                activity.finish();
            }
        }
    }
}
```

保证完全退出，可载代码后加入杀掉当前进程：

`android.os.Process.killProcess(android.os.Process.myPid());` killProcess()用于杀掉进程，接收一个进程id参数，使用myPid()方法获得当前程序进程id，注意不能使用这个方法杀掉其他程序

#### 10、启动活动最佳写法

```java
public static void actionStart(Context context,String data1,String data2){
    Intent intent = new Intent(context,TestActivity.class);
    intent.putExtra("param1",data1);
    intent.putExtra("param2",data2);
    context.startActivity(intent);
}
```

避免需要阅读源代码才知道需要传入什么参数来启动目标活动

### 三、UI界面

####1、常用控件

- TextView 显示文本，字体大小用sp单位

> 单行显示： `android:singleLine="true"` 
>
> 文本超出控件宽度时缩略： `android:elipsize="end"` end表示在尾部进行缩略

- Button

> 禁用自动大写： `android:textAllCaps="false"` 

- EditText 

> 指示性文本： `android:hint="something"` 
>
> 指定最大行数： `andorid:maxLines="1"` 
>
> 获取输入内容： `editText.getText().toString()` 
>
> 移动光标： `editText.setSelection()` 

- ImageView

> 指定图片： `android:src` 
>
> 缩放图片： `android:scaletype="centerCrop"` ，该参数指定保持原有比例填充满ImageView
>
> 在代码中动态更改图片： `imageView.setImageResource(R.drawable.img);` 

- ProgressBar 默认圆形旋转进度条

> 可见属性（所有控件通用）： `android:visibility` 有三个选择：visible（可见，默认值）、invisible（不可见，但仍占据原来的位置与大小）、gone（不仅不可见，且不占用屏幕）
>
> 使用代码设置： `progressBar.setVisibility()` ，传入View.VISIBLE、View.INVISIBLE、View.GONE
>
> 设置水平进度条： `style="?android:attr/progressBarStyleHorizontal"` 
>
> 设置进度条最大值： `android:max="100"` 
>
> 设置进度条进度：`progressBar.setProgress(100)` 

- AlertDialog 弹出对话框（置于所有界面元素之上）

```java
AlertDialog.Builder dialog = new AlertDialog.Builder(this);
dialog.setTitle("title");//设置对话框标题
dialog.setMessage("message");//设置对话框内容
dialog.setCancelable(false);//为true时按返回键可退出对话框
dialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        //确定按钮点击事件
    }
});
dialog.setNegativeButton("Cancle", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        //取消按钮点击事件
    }
});
dialog.show();
```

- ProgressDialog 弹出有进度条的对话框

```java
ProgressDialog progressDialog = new ProgressDialog(this);
progressDialog.setTitle("title");
progressDialog.setMessage("message");
progressDialog.setCancelable(true);
progressDialog.show();
```

- CheckBox 复选框，点击选中或取消

> 选中复选框：checkBox.setChecked(true)
>
> 判断复选框是否被选中：checkBox.isChecked()

#### 2、基本布局

- 线性布局LinearLayout

> 指定排列方向 `android:orientation` vertical（竖直排列）、horizontal（水平排列）
>
> 同一布局下的两个控件，一个控件只指定大小，而设定 `layout_weight="1"` 的控件会占满剩余空间
>
>  `android:layout_margin` 指定控件在上下左右的偏移距离

- 相对布局RelativeLayout

> android:layout_alignParentTop="true" 控件相对于父布局靠上
>
> android:layout_toLeftOf="@id/id" 控件相对于另一个控件（id）靠左
>
> android:layout_above(below)="@id/id" 控件相对于另一个控件（id）靠上（下）
>
> android:layout_alignLeft="@id/id" 控件左边缘与另一个控件（id）左边缘对齐

- 帧布局FrameLayout

> 应用少，所有控件默认摆放左上角

- 百分比布局：对RelativeLayout和FrameLayout进行扩展，PercentRelativeLayout和PercentFrameLayout

> 导入 implementation 'com.android.support:percent:24.2.1' ，然后需要定义app命名空间才能使用属性

#### 3、ListView

- 简单用法

```java
private String[] data = {"data"};
ArrayAdapter<String> adapter = new ArrayAdapter<>(this,android.R.layout.simple_list_item_1,data);//android.R.layout.simple_list_item_1是子项布局id，Android Q内置的布局文件
listView.setAdapter(adapter);
```

- 定制ListView

> 定义一个实体类，传入所需参数并提供get方法
>
> 新建子项布局文件
>
> 自定义适配器，继承自ArrayAdapter，重写构造函数，传入上下文Context、子项布局id、数据，重写getView（）方法
>
> ```java
> Test test = getItem(position);//获取当前实体类实例
> View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);//第三个参数false表示只在父布局声明的layout属性生效，但不为View添加父布局，View有父布局就不能添加到ListView中
> ```

####4、提升ListView运行效率

- 对布局进行缓存（在getView方法中）

```java
View view;
if (connvertView == null){//connvertView缓存了之前加载好的布局
    view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);
}else {
    view = connvertView;
}
```

- 对控件实例进行缓存（在getView方法中）

```java
View view;
ViewHolder viewHolder;
if (connvertView == null){//connvertView缓存了之前加载好的布局
    view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false);
    viewHolder = new ViewHolder();
    viewHolder.mTextView = view.findViewById(R.id,text);
    view.setTag(viewHolder);
}else {
    view = connvertView;
    viewHolder = (ViewHolder) view.getTag();
}
```

```java
class ViewHolder{
    TextView mTextView;
}
```

#### 5、ListView点击事件

```java
listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        //子项点击事件
    }
});
```

#### 6、RecyclerView

> 添加依赖 `implementation 'androidx.recyclerview:recyclerview:1.1.0'` 
>
> 适配器Adapter继承自RecyclerView.Adapter<>，其中泛型指定为RecyclerView.ViewHolder，例如：
>  `public class Adapter extends RecyclerView.Adapter<Adapter.ViewHolder>` ，其中Adapter.ViewHolder是Adapter的内部类： `static class ViewHolder extends RecyclerView.ViewHolder` ，然后还需要重写三个方法：onCreateViewHolder()、onBindViewHolder() 、getItemCount() 
>
> 适配器Adapter构造函数获取展示的数据
>
> 内部类ViewHolder构造函数要接收一个View参数，是RecyclerView子项最外层布局，然后就可以通过findViewById()方法获取控件实例
>
> onCreateViewHolder() 方法用于创建ViewHolder实例，绑定子项布局
>
> onBindViewHolder() 方法对子项数据进行赋值
>
> getItemCount() 方法返回子项个数

指定线性布局：

```java
LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this);
linearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);//设置布局排列方向，默认纵向排列
recyclerView.setLayoutManager(linearLayoutManager);
```

- GridLayoutManager 用于实现网络布局
- StaggeredGridLayoutManager 用于实现瀑布流布局

> 瀑布流布局宽度是根据列数自动配适的，宽度用match_parent

```java
StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL);//第一个参数是列数，第二个参数是排列方向
recyclerView.setLayoutManager(layoutManager);
```

#### 7、RecyclerView点击事件

重写onCreateViewHolder方法，可以具体到监听布局内某个控件的点击事件

#### 8、Nine-Patch图片

- 是一种特殊处理过的png图片，能够指定哪些区域可以被拉伸，哪些不可以

- .png格式的图片放进res目录下，右击选择create nine-patch即可

#### 9、UI其他

- RelativeLayout 中ListView无法滑动
- gravity设置自身内部元素对其方式，layout_gravity设置自身相对于父容器的对齐方式
- 隐藏标题栏：

```java
ActionBar actionBar =getSupportActionBar();
if (actionBar != null){
    actionBar.hide();
}
```

- 所有的控件都是直接或间接继承自View的，布局是继承ViewGroup的，ViewGroup是一种特殊的View

### 四、碎片Fragment

####1、碎片的使用

- 添加依赖 appcompat-v7库会引入support-v4库
- 动态添加碎片：

> 创建待添加碎片实例
>
> 获取FragmentManager，在活动中可以直接调用 getSupportFragmentManager() 方法得到：
>  `FragmentManager fragmentManager = getSupportFragmentManager();` 
>
> 开启一个事务： `FragmentTransaction transaction = fragmentManager.beginTransaction()` 
>
> 替换碎片，传入容器id和待添加碎片实例： `transaction.replace(R.id.layout,fragment);` 
>
> 提交事务： `transaction.commit();` 

- 碎片模拟返回栈： `fragmentTransaction.addToBackStack(null);` 接收一个名字描述返回栈状态，一般传入null
- 碎片活动之间通信：

> 活动中获得碎片实例： `getFragmentManager().findFragmentById(R.id.fragment);` 
>
> 碎片中获得相关联的活动实例： `getActivity()` 

 #### 2、碎片的生命周期

- 碎片的状态

> 运行状态：相关联活动处于运行状态时
>
> 暂停状态：相关联活动处于暂停状态时
>
> 停止状态：相关联活动处于停止状态时，或调用FragmentTransaction的remove()、replace()方法
>
> 销毁状态：相关联活动被销毁时，或调用FragmentTransaction的remove()、replace()方法

- 活动的回调方法在碎片中几乎都有，还有其他一些附加的回调方法：

> onAttach() 碎片与活动建立关联时调用
>
> onCreateView() 为碎片创建视图（加载布局）时调用
>
> onActivityCreated() 确保碎片与相关联活动一定创建完毕时调用
>
> onDestroyView() 碎片相关联视图被移除时调用
>
> onDetach() 碎片和活动解除关联时调用

- 碎片的生命周期

<img src="Image.assets\FragmentLifeCycle.jpg" alt="FragmentLifeCycle" style="zoom: 25%;" />

#### 3、动态加载布局

- 限定符Qualifiers

| 屏幕特征 | 限定符 |                  描述                   |
| :------: | :----: | :-------------------------------------: |
|   大小   | small  |            提供给小屏幕设备             |
|          | normal |           提供给中等屏幕设备            |
|          | large  |            提供给大屏幕设备             |
|          | xlarge |           提供给超大屏幕设备            |
|  分辨率  |  ldpi  |    提供给低分辨率设备（120dpi以下）     |
|          |  mdpi  |  提供给中等分辨率设备（120dpi~160dpi）  |
|          |  hdpi  |   提供给高分辨率设备（160dpi~240dpi）   |
|          | xhdpi  |  提供给超高分辨率设备（240dpi~320dpi）  |
|          | xxhdpi | 提供给超超高分辨率设备（320dpi~480dpi） |
|   方向   |  land  |             提供给横屏设备              |
|          |  port  |             提供给竖屏设备              |

- 最小宽度限定符

> 当程序运行在屏幕宽度大于600dp的设备上时，加载layout-sw600do/activity_main布局，否则加载
> layout/activity_main布局

### 五、广播机制

- 广播分为标准广播和有序广播，前者是完全异步执行的广播，所有广播接收器几乎同一时间接收此广播；后者是同步执行的广播，广播接收器有优先级，优先级高的可以截断正在传递的广播

#### 1、广播接收器

- 创建广播接收器

> 新建一个类，继承自BroadcastReceiver，重写父类onReceiver()方法
>
> 创建一个IntentFilter的实例，然后调用addAction()方法添加action，监听什么广播就添加什么action
>
> 调用registerReceiver()方法注册，传入Receiver实例和IntentFilter实例
>
> 动态注册的广播接收器一定要取消注册，一般在onDestroy()方法中调用unregisterReceiver()方法实现

- 判断是否有网络

```java
ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);//ConnectivityManager是一个系统服务类，专门管理网络连接
NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
```

再调用networkInfo的isAvailable()方法就知道是否当前有网络了

- 程序需要进行对用户来说比较敏感的操作时必须在配置文件中声明权限

#### 2、静态注册

- 动态注册的广播接收器只有在程序启动后才能接收，未启动接收用静态注册的方法
- 可以在Android Studio New一个Broadcast Receiver，Exported属性表示是否允许接收本程序以外的广播，Enabled属性表示是否启用这个广播接收器
- 静态注册的广播接收器一定要在AndroidManifest.xml中注册（<receiver>标签）才能使用
- onReceiver() 方法中不能添加过多的逻辑或者耗时操作，当onReceiver()方法运行了较长时间而没有结束时，程序就会报错

#### 3、发送自定义广播

> 构建一个Intent对象： `Intent intent = newIntent("包名.MY_BROADCAST");` 
>
> 发送广播： `sendBroadcast(intent);` 

由于广播是使用Intent进行传递的，所以可以在Intent中携带一些数据传递给广播接收器

#### 4、发送有序广播

- 将 `sendBroadcast()` 改为 `sendOrderedBroadcast()` ，接收两个参数，第一个是Intent，第二个是与权限相关的字符串，没有传null
- 在注册的时候设定广播接收器的优先级

> 在<receiver>标签中的<intent-filter>标签中通过 android:priority 给广播接收器设置优先级

- 如果在onReceiver()方法中调用了abortBroadcast()方法，就表示截断此广播

#### 5、使用本地广播

上面的广播全部都是全局广播，即可以被其他应用接收到，使用本地广播只能进行程序内部传递，解决了安全问题

> 获取LocalBroadcastManager实例：
>  `LocalBroadcastManager manager = LocalBroadcastManager。getInstance(this)` 
>
> 发送本地广播： `manager.sendBroadcast(intent)` 
>
> 注册本地广播接收器： `manager.registerReceiver(Receiver,intentFilter)` 

本地广播无法通过静态注册来接收，因为发送本地广播时程序已经启动

#### 6、常用广播

- 系统启动时： `android.intent.action.BOOT_COMPLETED` 
- 网络变化时： `android.net.conn.CONNECTIVITY_CHANGE` 

### 六、持久化技术

持久化技术提供了一种机制可以让数据在瞬时和持久状态之间转换，主要有文件存储、SharePreference存储、数据库存储，除此之外还有SD卡存储

#### 1、文件存储

- 不对数据进行格式化处理，适合存储一些简单的文本数据或二进制数据

（1）存储数据至文件

- Context类提供了一个openFileOutput()方法，返回一个FileOutputStream对象，可以使用java流写入数据；这个方法接收两个参数，第一个是文件名，但不能包含路径，所有文件默认存储到 /data/data/<package name>/files 目录下；第二个参数是文件操作模式，默认是Context.MODE_PRIVATE，文件名相同时会覆盖原文件，而Context.MODE_APPEND表示若文件已存在，则追加内容，否则新建文件

```java
BufferedWriter writer = null;
try {
    FileOutputStream out = openFileOutput("data",Context.MODE_PRIVATE);
    writer = new BufferedWriter(new OutputStreamWriter(out));
    writer.write("data");
}catch (IOException e){
    e.printStackTrace();
}finally {
    try {
        if (writer != null){
            writer.close();
        }
    }catch (IOException e){
        e.printStackTrace();
    }
}
```

- Android Studio查看模拟器文件夹

> 导航栏 - Tools - Android - Android Device Monitor - File Explorer

（2）从文件中读取数据

- Context类还提供了一个openFileInput()方法，用于从文件中读取数据，并返回一个FileInputStream对象，该方法接收一个参数，即要读取的文件名，然后系统会自动到 /data/data/<package name>/files 目录去找，再通过java流读取

```java
BufferedReader reader = null;
try {
    FileInputStream in = openFileInput("data");
    reader = new BufferedReader(new InputStreamReader(in));
    String line = "";
    while ((line = reader.readLine()) != null){
        StringBuilder content = new StringBuilder();
        content.append(line);
    }
}catch (IOException e){
    e.printStackTrace();
}finally {
    try {
        if (reader != null){
            reader.close();
        }
    }catch (IOException e){
        e.printStackTrace();
    }
}
```

- TextUtils.isEmpty() 方法可以判断字符串是否为空，当传入字符串为null或者是空字符串时都返回true

#### 2、SharedPreferences存储

- 使用键值对的方式存储数据，支持多种数据类型
- SharedPreferences文件使用XML格式对数据进行管理
- SharePreferences文件都是存放在 /data/data/<package name>/shared_prefs/ 目录下

（1）获取SharePreferences的三种方法：

- Context类的getSharePreferences() 方法

> 第一个参数指定SharePreferences文件的名称，第二个参数指定操作模式，目前只有MODE_PRIVATE一种默认模式，和传入0效果一样，表示当前程序才可以读写该SharePreferences文件

- Activity类的getPerferences() 方法，只接收一个模式参数，因为会自动将当前活动类名作为SharePreferences的文件名
- PreferenceManager类中的getDefaultSharedPreferences() 方法，接收一个Context参数，将当前活动类名作为前缀命名SharePreferences的文件

（2）存储数据

- 调用SharedPreferences的edit() 方法获取一个SharedPreferences.Editor对象
- 向SharedPreferences.Editor对象添加数据，布尔型用putBoolean() 方法，以此类推
- 调用apply() 方法提交数据

```java
SharedPreferences.Editor editor = getSharedPreferences("data",MODE_PRIVATE).edit();
editor.putString("data_key","data_value");
editor.apply();
editor.clear();//清除掉SharedPreferences文件的所有数据
```

（3）读取数据

SharedPreferences对象提供了一系列get方法，例如读取布尔型就是getBoolean() 方法，以此类推，这些get方法接收两个参数，一个是键，另一个是默认值，表示传入键找不到对应值时以该默认值返回

```java
SharedPreferences preferences = getSharedPreferences("data",MODE_PRIVATE);
String s = preferences.getString("data_key","默认值");
```

#### 3、SQLite数据库存储

- SQLite是一款轻量级关系型数据库，运算速度非常快，占用资源很少，通常只需要几百KB，不仅支持SQL语法，还遵循ACID事务
- 数据库存放在 /data/data/<package name>/databases/ 目录下 

（1）创建数据库

- 抽象类SQLiteOpenHelper 可以对数据库进行创建和升级

> 分别需要重写两个方法：onCreate() 、onUpgrade()
>
> 其中还有两个实例方法：getReadableDatabase()、getWritableDatabase()，这两个方法都可以创建或打开一个现有的数据库，返回一个可对数据库进行读写操作的对象，当数据库不可写入时（如磁盘空间已满），getReadableDatabase() 方法返回的对象以只读方式打开数据库，而getWritableDatabase() 方法出现异常
>
> SQLiteOpenHelper 中有两个构造函数，一般使用参数少一点的（4个参数），第一个参数是Context，第二个参数是数据库名，第三个参数允许我们在查询数据是返回一个自定义的Cursoe，一般传入null，第四个参数是当前数据库的版本号，可以用于对数据库的升级，
>
> SQL语句用SQLiteDatabase的execSQL方法执行

- Android Studio自带查看数据库调试工具adb shell，存放在SDK的platform-tools目录下，将platform-tools添加进环境变量Path就可以在命令行窗口使用，cd进入数据库目录，ls查看文件，sqlite打开数据库（sqlite3 数据库名），.table查看数据库的表，.schema查看建表语句，.exit / .quit退出

（2）升级数据库

- 在onUpgrade() 方法中删除原先的表再重新创建
- 修改SQLiteOpenHelper 构造函数第四个参数（版本号），传入比之前大的值即可调用onUpgrade() 方法

（3）添加数据

- 操作数据无非有4种：CRUD（创建Create、查询Retrieve、更新Update、删除Delete）
- SQLiteOpenHelper 的两个实例方法getReadableDatabase()、getWritableDatabase() 都返回一个SQliteDatabase对象，该对象提供了insert() 方法用于添加数据，接收三个参数，第一个是表名，第二个是未指定添加数据时可给某些为空的列自动赋值NULL，一般不用只传入null，第三个是一个ContentValues对象，提供一系列put方法重载

```java
MySQLiteOpenHelper dbHelper = new MySQLiteOpenHelper(this,"Book.db",null,1);
SQLiteDatabase db = dbHelper.getWritableDatabase();
ContentValues values = new ContentValues();
values.put("name","data");
db.insert("Book",null,values);//插入数据
db.update("Book",values,"name = ?",new String[]{"bookname"});//更新name为bookname的数据
db.delete("Book","pages > ?",new String[]{"500"});//删除pages大于500的数据
```

（4）更新数据

- SQliteDatabase提供了一个update() 方法，用于更新数据，接收四个参数，第一个是表名，第二个是ContentValues对象，第三个和第四个用于约束行的数据，不指定就默认更新所有行

（5）删除数据

- SQliteDatabase提供了一个delete() 方法，用于删除数据，接收三个参数，第一个是表名，第二个和第三个用于约束行的数据，不指定就默认删除所有行

（6）查询数据

- SQliteDatabase提供了一个query() 方法，用于查询数据，接收七个参数，第一个是表名，第二个指定查询哪几列，不指定默认查询所有列，第三个和第四个用于约束行的数据，不指定就默认查询所有行，第五个指定需要去group by的列，不指定表示不进行group by操作，第六个用于对group by之后的数据进一步过滤，不指定表示不过滤，第七个用于指定查询结果的排列方式，不指定表示使用默认的排列方式

```java 
MySQLiteOpenHelper dbHelper = new MySQLiteOpenHelper(this,"Book.db",null,1);
SQLiteDatabase db = dbHelper.getWritableDatabase();
Cursor cursor = db.query("Book",null,null,null,null,null,null);
if (cursor.moveToFirst()){//moveToFirst() 方法将数据指针移至第一行
	do{
		String name = cursor.getString(cursor.getColumnIndex("name"));//getColumnIndex() 方法获取某一列在表中对应的位置索引
	}while(cursor.moveToNext());
}
cursor.close;//最后记得调用close关闭Cursor
```

（7）使用SQL操作数据库

- 除了查询数据用SQLiteDatabase的rawQuery() 方法，其他操作都是调用exeSQL() 方法

#### 4、使用LitePal操作数据库

- LitePal是一款开源的Android数据库框架，采用对象关系映射（ORM）模式，对平时开发常见的一些数据库操作功能进行封装，开发语言面向对象，数据库则是关系型数据库，在这两者之间建立一种映射关系，就是对象关系映射

- 大多数开源软件会上传到 jcenter 上，在app/build.gradle文件中的dependencies闭包中声明引用：
   `implementation 'org.litepal.android:core:1.3.2'` 

- 新建assets目录，目录下新建 litepal.xml 文件：

  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <litepal>
      <dbname value="Book"></dbname><!--dbname标签指定数据库名-->
      <version value="1"></version><!--version标签指定数据库版本号-->
      <list></list><!--list标签指定映射类型-->
  </litepal>
  ```

- 在AndroidManifest.xml文件中的<application>标签中加入：
   `android:name="org.litepal.LitePalApplication"` 

（1）创建和升级数据库

- 新建一个类，定义字段，并生成响应的getter和setter方法，是典型的 java bean，对应数据库的一个表，类中的字段对应表中每一列

- 修改 litepal.xml 文件：

  ```XML
  <list>
  	<mapping class = "包名.类"></mapping><!--声明映射模型类-->
  </list>
  ```

- 调用Connector.getDatabase() 方法自动创建数据库，其中 table_schema 表是 LitePal 内部用的
- 升级数据库就改相应的类和 litepal.xml 文件（再加一个表），然后版本号加1

（2）添加数据

- 进行CRUD操作时要继承DataSupport类
- 使用set方法设置各种数据，然后调用 save()方法保存

```java
public class Book extends DataSupport{
    ...
}

Book book = new Book();
book.setName("name");//添加数据
book.save();//保存数据
book.setToDefault("pages");//设定默认值
book.updateAll("name = ? and author = ?","name","author");//更新数据
DataSupport.deleteAll(Book.class,"price < ?","15");//删除数据
List<Book> book = DataSupport.findAll(Book.class);//查询数据
List<Book> books = DataSupport.select("name","author")
    						.where("pages > ?","400")
    						.order("pages")
    						.limit(10)//查询前10条数据
    						.offset(10)//偏移10条，即查询第10条之后的数据
    						.find(Book.class);
```

（3）更新数据

- 用 isSaved() 方法可以判断对象是否已经储存，返回true表示是，只有在调用了save() 方法或者通过LitePal提供的查询API查询出来的才会返回true
- 一种方法是对对象重新设值，然后重新滴调用save() 方法，但只能操作已存储的对象
- 另一种方法是调用updataAll() 方法执行更新操作，可以指定一个条件约束，不指定就更新所有数据
- 把字段更新成默认值不能用set方法，当new出一个对象时，所有字段都被初始化为默认值了，用set方法LitePal不会对该列更新，需要用setToDefault() 方法，传入相应列名

（4）删除数据

- 一种方法是对已存储的对象调用delete() 方法即可
- 另一种方法调用DataSupport.deleteAll() 方法，第一个参数指定删除哪张表的数据，后面的参数用于指定约束条件，不加指定条件默认删除所有数据

（5）查询数据

- 调用DataSupport.findnAll() 方法，传入表对应类，返回该类的List集合
- 查询第一条数据DataSupport.findFirst()
- 查询最后一条数据DataSupport.findLast()
- 通过连缀指定查询功能

> select() 用于指定查询哪几列的数据
>
> where() 用于指定查询约束条件
>
> order() 用于指定查询结果的排序方式，desc表示降序，asc或者不写表示升序
>
> limit() 用于指定查询结果的数量
>
> offset() 用于指定查询结果的偏移量

- 可以使用SQL来查询：DataSupport.findBySQL() 来进行原生查询，第一个参数指定SQL语句，后面参数指定占位符的值，该方法返回一个Cursor的对象

### 七、内容提供器

- 用于在不同应用程序之间实现数据共享的功能，保证了被访问数据的安全性
- 一般用法有两种，一种是使用现有的内容提供器，另一种是创建自己的内容提供器

#### 1、运行时权限

- 6.0系统加入了运行时权限功能：用户不需要在安装软件的时候一次性授权所有的权限，可以在软件使用过程中再对某一权限授权
- Android的权限分为普通权限和危险权限，普通权限是那些不会威胁到用户安全和隐私的权限，系统会自动授权，不需手动操作，而危险权限需要用户手动授权

<img src="Image.assets\DangerousAuthority.jpg" alt="DangerousAuthority" style="zoom: 25%;" />

- 判断权限是否授权

> 调用ContextCompat.checkSelfPermission() 方法，接收两个参数，第一个是Context，第二个是具体的权限名，然后返回值和PackageManager.PERMISSION_GRANTED 作比较，相等说明已授权，否则未授权
>
> 没有授权的话调用ActivityCompat.requestPermissions() 方法向用户申请授权，接收三个参数，第一个是Activity实例，第二个是String数组，存放待申请的权限名，第三个是请求码，只要是唯一值即可，调用该方法会弹出一个权限申请对话框，无论授权与否，都会回调onRequestPermissionsResult() 方法，而授权结果封装在grantResults 参数中

#### 2、常用action

- 打电话： `Intent.ACTION_CALL` ，data指定协议是tel，需要声明权限
- 打开拨号界面： `Intent.ACTION_DIAL` 不需要声明权限
- 打开相机： `android.media.action.IMAGE_CAPTURE` 

#### 3、常用权限

- `<uses-permission android:name="..."/>`
- 打电话权限： `android.permission.CALL_PHONE` 
- 访问系统网络状态： `android.permission.ACCESS_NETWORL_STATE` 
- 读取联系人： `android.permission.READ_CONTACTS` 
- 手机振动： `android.permission.VIBRATE` 
- 读取SD卡： `android.permission.WRITE_EXTERNAL_STORAGE` 、
- 访问网络： `android.permission.INTERNET` 

#### 4、访问其他程序中的数据

- 借助ContentResolver类，使用Context中的getContentResolver() 方法获取该类的实例

- ContentResolver提供了一系列方法对数据库进行CRUD操作，有insert() 添加数据，update() 更新数据，delete() 删除数据，query() 查询数据，这些方法都只接收一个内容URI参数，数据组装到ContentValues中
- 内容URI由authority和path组成，authority用于区分不同程序，一般为了避免冲突，会使用程序包名来命名；path是区分同一程序的不同表，通常会加到authority的后面；然后还需要在字符串头部加上协议：
   `content://com.example.app.provider/table1` ，用Uri.parse() 方法可以将URI字符串解析成Uri对象
- 查询联系人数据传入的Uri： ContactsContract.CommonDataKinds.Phone已经封装好，提供一个CONTENT_URI常量，该常量就是用Uri.parse() 方法解析出来的结果

- 查询:

```java
Cursor cursor = getContentResolver().query(
		uri,
		projection,
		selection,
		selectionArgs,
		sortOrder);
```

| query()方法参数 |         对应SQL          |             描述             |
| :-------------: | :----------------------: | :--------------------------: |
|       uri       |     from table_name      | 指定查询某个应用程序下某张表 |
|   projection    |  select column1,column2  |        指定查询的列名        |
|    selection    |   where column = value   |      指定where约束条件       |
|  selectionArgs  |            -             |  为where中占位符提供具体值   |
|     orderBy     | order by column1,column2 |     指定查询结果排列方式     |

得到一个Cursor对象，通过移动游标的位置遍历所有行，取出数据后close

#### 5、创建内容提供器

- 继承ContentProvider来创建，需要重写6个方法，onCreate()、query()、insert()、update()、delete()、getType()

> onCreate() 完成数据库创建和升级等操作，返回true初始化成功，false失败
>
> query() 使用uri参数查询表，projection参数确定列，selection和selectionArgs参数约束查询行，sortOrder参数对结果排列，查询结果存放在Cursor对象返回
>
> insert() 使用uri参数确定添加表，待添加数据保存在values参数中，完成后返回一个表示这条新纪录的URI
>
> update() 使用uri参数确定更新表，新数据保存在values中，selection和selectionArgs参数约束查询行，受影响的行数将作为返回值
>
> delete() 使用uri参数确定删除表，selection和selectionArgs参数约束查询行，被删除的行数将作为返回值
>
> getType() 根据传入内容URI返回响应的MIME类型

- 可以在uri后加一个id： `content://com.example.app.provider/table1/1` 表示table1表中id为1的数据，可以使用通配符的方式分别匹配这两种格式（没带id和带id）：

> \*：表示匹配任意字符， `content://com.example.app.provider/*` ，表示匹配任意表
>
> \#：表示匹配任意数字， `content://com.example.app.provider/table/#` ，表示匹配表中任意行数据

- UriMatcher类可以实现匹配URI的功能，该类提供了addURI() 方法，接收三个参数，分别是authority、path、自定义代码，这样当调用UriMatcher的match() 方法时，可以将一个Uri对象传入（可以用通配符），返回这个Uri对象对应的自定义代码

- MINE类型：例子：vnd.android.cursor.dir/vnd.com.example.app.provider.table

> 以vnd开头
>
> 若内容URI以路径结尾，则后接android.cursor.dir/，若以id结尾，则后接android.cursor.item/
>
> 最后接上vnd.<authority>.<path>

- Uri对象的getPathSegments() 方法会将内容URI权限之后的部分以"/."符号进行分割，并把分割后的解过放到一个字符串列表中
- 内容提供器的注册：在AndroidManifest.xml 文件中的<application>标签中的<provider>标签

> android:name 指定DatabaseProvider的类名
>
> android:authorities 指定DatabaseProvider的authority
>
> android:enabled和android:exported 为true表示允许DatabaseProvider被其他应用程序访问

### 八、手机多媒体

#### 1、通知（Notification）

（1）使用通知

- 需要一个NotificationManager类来管理通知，调用Context的getSystemService() 方法获取，接收一个字符串参数用于确定获取系统的服务

- 再使用Builder构造器创建Notification对象，support-v4库提供了一个NotificationCompat类，使用该类的构造器创建Notification对象

> setContentTitle() 指定通知标题
>
> setContentText() 指定通知正文内容
>
> setWhen() 指定通知被创建的时间，以毫秒为单位
>
> setSmallIcon() 设置通知的小图标（显示在系统状态栏上），只能用纯alpha图层的图片
>
> setLargeIcon() 设置通知的大图标（下拉状态栏显示）
>
> setProgress() 设置进度条，第一个参数是最大进度，第二个参数是当前进度，第三个是是否使用模糊进度条

- 调用NotificationManager的notify() 方法即可显示通知，第一个参数是id，需要保证每个通知的id都是不同的，第二个参数是Notification对象

```java
NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
Intent Intent = new Intent(this,Activity.class);
PendingIntent pi = PendingIntent.getActivity(this,0,intent,0);
Notification notification = new NotificationCompat.Builder(MainActivity.this,"default")
                            .setContentTitle("title")//设置通知标题
                            .setContentText("text")//设置通知文本
                            .setWhen(System.currentTimeMillis())//设置通知时间
                            .setSmallIcon(R.mipmap.ic_launcher)//设置通知小图标
    .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher))//设置通知图标
    					  .setContentIntent(pi)//设置通知点击事件
    					  .setAutoCancel(true)//通知被点击时关闭
                            .build();
manager.notify(1,notification);
```

（2）通知点击事件

- PendingIntent和Intent相似，前者倾向于在某个合适的时机去执行某个动作，后者倾向于立即执行某个动作，PendingIntent可以理解为延迟执行的Intent
- 获取PendingIntent实例有三个静态方法：getActivity()、getBroadcast()、getService()，接收参数一样，第一个是Context，第二个一般用不到，传入0即可，第三个是Intent对象，第四个用于确定PendingIntent的行为，有FLAG_ONE_SHOT、FLAG_NO_CRATE、FLAG_CANCEL_CURRENT、FLAG_UPDATE_CURRENT四个参数，通常情况传入0
- NotificationCompat.Builder还可以连缀一个setContentIntent() 方法，接收一个PendingIntent对象
- NotificationCompat.Builder还可以连缀一个setAutoCancel() 方法，传入true用于取消通知的显示，另一种取消方法是显示地调用NotificationManager的cancel() 方法，传入通知的id

（3）通知进阶

- 连缀一个setSound() 方法，在通知发出时会播放一段音频，接收一个Uri参数
- 连缀一个setVibrate() 方法，通知到来时震动，接收一个长整形数组参数，以毫秒为单位，下标偶数为静止时间，下标奇数为震动时间
- 连缀一个setLight() 方法，通知来时呼吸灯，接收三个参数，第一个指定LED灯颜色，第二个指定亮起时长，以毫秒为单位，第三个参数指定暗去时长，以毫秒为单位，也可以直接使用默认效果： `.setLight(NotificationCompat.DEFAULT_ALL)` 
- 连缀一个setStyle() 方法，构建富文本信息（长文字、图片），接收一个NotificationCompat.Style 参数，设置长文字： `.setStyle(new NotificationCompat.BigTextStyle().bigText("text"))` ，设置图片： `.setStyle(new NotificationCompat.BigPicture().bigPicture(BitmapFactory.decodeResoure(getResources(),R.drawable.img)))` 用Bitmap将图片解析成Bitmap对象
- 连缀一个setPriority() 方法，设置通知的重要程度，一共5个值可选：PRIORITY_DEFAULT表示默认重要程度、PRIORITY_MIN、PRIORITY_LOW、PRIORITY_HIGH、PRIORITY_MAX的优先级从低到高，PRIORITY_MAX不会在通知栏显示一个小图标，而是直接弹出横幅，附带详细内容，开发时要谨慎使用，避免用户反感

#### 2、调用摄像头和相册

（1）调用摄像头

- 创建一个File对象来存放拍下的照片，并存放在SD卡的应用关联缓存目录下（SD卡中专门存放当前应用缓存数据的位置），具体路径是 /sdcard/Android/data/<package name>/cache ，用getExternalCacheDir() 方法可得到
- 从7.0系统开始，使用真实路径的Uri被认为不安全，会抛出FileUriExposedException 异常，而FileProvider是一种特殊的内容提供器，可以有选择地将封装的Uri共享给外部，提高了安全性

```java
//创建File对象，用于存放照片
File image = new File(getExternalCacheDir(),"iamge.jpg");
Uri imageUri;
try {
    if (image.exists()){
        image.delete();
    }
    image.createNewFile();
}catch (IOException e){
    e.printStackTrace();
}
if (Build.VERSION.SDK_INT >= 24){
    imageUri = FileProvider.getUriForFile(this,"com.example.test.fileprovider",image);//使用了内容提供器
}else {
    imageUri = Uri.fromFile(image);//使用本地真实路径
}
//启动相机
Intent intent = new Intent("android.media.action.IMAGE_CAPTURE");
intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);
startActivityForResult(intent,1);

@Override
protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
    switch (requestCode){
        case 1:
            if (resultCode == RESULT_OK){
                try {
                    //显示照片
                    Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));//解析成Bitmap对象
                    imageView.setImageBitmap(bitmap);
                }catch (FileNotFoundException e){
                    e.printStackTrace();
                }
            }break;
        default:break;
    }
}
```

- 在AndroidManifest.xml 中注册内容提供器，<provider>标签下的 android:authorities 属性要和FileProvider.getUriForFile方法的第二个参数一致，然后在内部用<meta-data>标签指定Uri共享路径

```xml
<provider
          android:name="android.support.v4.content.FileProvider"
          android:authorities="com.example.test.fileprovider"
          android:exported="false"
          android:grantUriPermissions="true">
    <meta-data
               android:name="android.support.FILE_PROVIDER_PATHS"
               android:resource="@xml/file_paths"/><!--在下面创建一个资源-->
</provider>
```

- 创建@xml/file_paths资源：

```xml
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <extranal-path name="image" path=""/><!--指定Uri共享，path表示共享的具体路径，设置空值表示共享整个SD卡-->
</paths>
```

（2）从相册中选择照片

- 动态获取权限

```java
if (ContextCompat.checkSelfPermission(this,权限名) != PackageManager.PERMISSION_GRANTED){
	ActivityCompat.requestPermissions(this,new String[]{权限名},1);
} else{
	...
}

@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    switch (requestCode){
        case 1:
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED){
                ...
            }else {
                ...
            }break;
        default:break;
    }
}
```

- 打开相册

> 从4.4版本开始，选取相册图片返回不是图片真实的uri，而是一个封装过的uri，如果封装的uri是document类型，需要去除document id进行处理，否则使用普通方法获得，另外Uri的authority是media格式时，获取id还需要在进行一次解析

```java
Intent intent = new Intent("android:intent.action.GET_CONTENT");
intent.setType("image/*");
startActivityForResult(intent,1);

@Override
protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
    switch (requestCode){
        case 1:
            if (requestCode == RESULT_OK) {
                //判断手机系统版本
                if (Build.VERSION.SDK_INT >= 19){
                    //4.4及以上版本使用这个方法
                    handleImageOnKitKat(data);
                }else {
                    //4.4以下的系统使用这个方法
                    handleImageBeforeKitKat(data);
                }
            }break;
        default:break;
    }
}

@TargetApi(19)
private void handleImageOnKitKat(Intent data){
    String imagePath = null;
    Uri uri = data.getData();
    if (DocumentsContract.isDocumentUri(this,uri)){
        //如果是document类型的uri，通过document id 处理
        String docId = DocumentsContract.getDocumentId(uri);
        if ("com.android.provider.media.documents".equals(uri.getAuthority())){
            String id =docId.split(":")[1];//解析出数字格式的id
            String selection = MediaStore.Images.Media._ID + "=" +id;
            imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection);
        }else if ("com.android.providers.downloads.documents".equals(uri.getAuthority())){
            Uri contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"),Long.valueOf(docId));
            imagePath = getImagePath(contentUri,null);
        }
    }else if ("content".equalsIgnoreCase(uri.getScheme())){
        //如果是content类型的uri，使用普通方法处理
        imagePath = getImagePath(uri,null);
    }else if ("file".equalsIgnoreCase(uri.getScheme())){
        //如果是file类型的uri，直接获取图片的路径
        imagePath = uri.getPath();
    }
    displayImage(imagePath);
}

private void handleImageBeforeKitKat(Intent data) {
    Uri uri =data.getData();
    String imagePath = getImagePath(uri,null);
    displayImage(imagePath);
}

private String getImagePath(Uri uri, String selection) {
    String path = null;
    //通过Uri和selection来获取真实的图片路径
    Cursor cursor = getContentResolver().query(uri,null,selection,null,null);
    if (cursor != null){
        if (cursor.moveToFirst()){
            path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));
        }
        cursor.close();
    }
    return path;
}
    
private void displayImage(String imagePath) {
    if (imagePath != null){
        Bitmap bitmap = BitmapFactory.decodeFile(imagePath);
        imageView.setImageBitmap(bitmap);
    }else {
        ...
    }
}
```

#### 3、播放多媒体

（1）播放音频

- 一般使用MediaPlayer类来实现，该类提供了全面的方法，首先需要创建一个MediaPlayer对象，调用setDataSource() 方法设置音频文件的路径，再调用prepare() 方法使MediaPlayer进入准备状态，调用start() 方法开始播放，调用pause() 方法会暂停，reset() 方法会停止播放

![MediaPlayer](Image.assets\MediaPlayer.jpg)

```java
MediaPlayer player = new MediaPlayer();
try {
    File file = new File(Environment.getExternalStorageDirectory(),"music.mp3");
    player.setDataSource(file.getPath());//指定音频路径
    player.prepare();//进入准备阶段
    player.start();//开始播放
    player.pause();//暂停播放
    player.reset();//停止播放
    player.stop();//
    player.release();//释放资源
}catch (Exception e){
    e.printStackTrace();
}
```

（2）播放视频

- 主要使用VideoView类来实现

![VideoView](Image.assets\VideoView.jpg)

```java
File file = new File(Environment.getExternalStorageDirectory(),"video.mp3");
videoView.setVideoPath(file.getPath());//指定视频文件路径
videoView.start();//开始播放
videoView.pause();//暂停播放
videoView.resume();//重新播放
videoView.suspend();//释放资源
```

- VideoView背后是用MediaPlayer对视频文件进行控制的，只不过做了封装

### 九、使用网络技术

####1、WebView控件

> 使用findViewById() 方法获取WebView实例
>
> getSettings() 方法可以设置一些浏览器属性，像支持JavaScript脚本： `webView.getSettings().setJavaScriptEnabled(true)` 
>
> setWebViewClient() 方法传入一个WebViewClient实例，当需要从一个网页跳转到另一个网页时，目标网页在WebView中显示，而不是打开系统浏览器 `webView.setWebViewClient(new WebViewClient())` 
>
> 调用loadUrl() 方法，传入网址 `webView.loadUrl("网址")` 
>
> 需要访问网络权限

#### 2、使用HTTP协议访问网络

（1）使用HttpURLConnection

- 过去发送HTTP请求的一般有HttpURLConnection 和 HttpClient，由于HttpClient存在API数量多，扩展困难的缺点，在6.0系统已被移除
- 先new一个URL对象，传入目标地址，调用openConnection() 方法

```java
URL url = new URL("http://www.baidu.com");
HttpURLConnection connection = (HttpURLConnection) url.openConnection();
connection.setRequestMethod("GET");//请求方法GET
connection.setConnectTimeout(8000);//设置连接超时
connection.setReadTimeout(8000);//读取超时时间
InputStream in = connection.getInputStream();//获取服务器返回的输入流
DataOutputStream out = new DataOutputStream(connection.getOutputStream());//获取输出流
out.writeBytes("username=admin&password=123456");//用POST时提交的数据，以键值对形式
connection.disconnect();//关闭HTTP连接
```

- HTTP请求使用的方法有GET和POST，前者表示希望从服务器获取数据，后者希望提交数据给服务器 
- Android不允许在子线程中进行UI操作，使用runOnUiThread() 方法将线程切换至主线程即可

（2）使用OkHttp

- 开源，项目地址：http://github.com/square/okhttp
- 添加库依赖： `implementation 'com.squareup.okhttp3:okhttp:3.4.1'` ，会自动下载两个库，OkHttp库和Okio库，后者是前者的通信基础
- 创建一个OkHttpClient实例，如果想要发起一条HTTP请求，需要创建一个Request对象，可以在build() 方法之前连缀其他方法来丰富

```java
OkHttpClient client = new OkHttpClient();
Request request = new Request.Builder()
                    .url("http://www.baidu.com")//通过uri设置网络地址
                    .build();
Response response = client.newCall(request).execute();//发送请求获取服务器返回的数据
String responseData = response.body().string();//得到返回的具体内容
//发送POST请求
RequestBody requestBody = new FormBody.Builder()//构造一个RequestBody对象存放待提交参数
    				.add("username","admin")
    				.add("password","123456")
    				.build();
Request request = new Request.Builder()
    				.url("http://www.baidu.com")//通过uri设置网络地址
    				.post(requestBody)//调用post() 方法，传入RequestBody对象
    				.build();
Response response = client.newCall(request).execute();//发送请求获取服务器返回的数据
String responseData = response.body().string();//得到返回的具体内容
```

#### 3、解析XML格式数据

- 网络传输数据常用格式：XML和JSON，还有DOM（这里不讲解）

（1）Pull解析方式

- XML解析有两种，Pull解析和SAX解析
- 服务器返回如下XML格式数据

```xml
<apps>
	<app>
		<id>1</id>
		<name>Name</name>
	</app>
	<app>
		<id>2</id>
		<name>Name1</name>
	</app>
</apps>
```

- 使用Pull解析方式

```java
OkHttpClient client = new OkHttpClient();
Request request = new Request.Builder()
                    .url("http://...xml")//通过uri设置网络地址
                    .build();
Response response = client.newCall(request).execute();//发送请求获取服务器返回的数据
String responseData = response.body().string();//得到返回的具体内容

try {
    XmlPullParserFactory factory = XmlPullParserFactory.newInstance();//获取XmlPullParserFactory实例
    XmlPullParser xmlPullParser = factory.newPullParser();//借助XmlPullParserFactory实例获取XmlPullParser对象
    xmlPullParser.setInput(new StringReader(responseData));//设置服务器返回的XML数据
    int evenType = xmlPullParser.getEventType();//得到当前的解析事件
    String id = "";
    String name = "";
    while (evenType != XmlPullParser.END_DOCUMENT){//不等于XmlPullParser.END_DOCUMENT说明解析未完成
        String nodeName = xmlPullParser.getName();//得到当前节点的名字
        switch (evenType){
                //开始解析某个节点
            case XmlPullParser.START_TAG:{
                if ("id".equals(nodeName)){
                    id = xmlPullParser.nextText();
                } else if ("name".equals(nodeName)){
                    name = xmlPullParser.nextText();
                }
            }break;
                //完成某个节点的解析
            case XmlPullParser.END_TAG:{
                if ("app".equals(nodeName)){
                    ...
                }break;
            }
            default:break;
        }
        evenType = xmlPullParser.next();//获取下一个解析事件
    }
}catch (Exception e){
    e.printStackTrace();
}
```

- 10.0.2.2对于模拟器来说是电脑本地的IP地址

（2）SAX解析方式

- 新建一个类继承自DefaultHandler，重写5个方法，startDocument（开始解析XML时调用）、startElement（开始解析某个节点时调用）、characters（获取节点时内容调用）、endElement（完成某个节点的解析时调用）、endDocument（完成整个XML文件的解析时调用）
- 注意，characters可能被多次调用，一些换行符也被解析出来，需要加以控制，可以调用 trim() 方法删除多于的回车或空格

```java
public class ContentHandler extends DefaultHandler {
    private String nodeName;
    private StringBuilder id;
    private  StringBuilder name;

    @Override
    public void startDocument() throws SAXException {
        id = new StringBuilder();
        name = new StringBuilder();
    }

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
        //记录当前节点名
        nodeName = localName;
    }

    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        //根据当前节点名判断内容添加到哪一个StringBuilder当中
        if ("id".equals(nodeName)){
            id.append(ch,start,length);
        } else if ("name".equals(nodeName)){
            name.append(ch,start,length);
        }
    }

    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException {
        if ("app".equals(localName)){
            ...
            //清空掉StringBuilder
            id.setLength(0);
            name.setLength(0);
        }
    }

    @Override
    public void endDocument() throws SAXException {
        super.endDocument();
    }
}
```

```java
OkHttpClient client = new OkHttpClient();
Request request = new Request.Builder()
                    .url("http://...xml")//通过uri设置网络地址
                    .build();
Response response = client.newCall(request).execute();//发送请求获取服务器返回的数据
String responseData = response.body().string();//得到返回的具体内容

try {
    SAXParserFactory factory = SAXParserFactory.newInstance();//创建SAXParserFactory对象
    XMLReader reader = factory.newSAXParser().getXMLReader();//根据SAXParserFactory对象获取XMLReader对象
    ContentHandler handler = new ContentHandler();
    //将ContentHandler的实例设置到XMLReader中
    reader.setContentHandler(handler);
    //开始解析
    reader.parse(new InputSource(new StringReader(responseData)));
} catch(Exception e){
    e.printStackTrace();
}
```

#### 4、解析JSON格式数据

- JSON比XML体积更小，省流量，缺点是不如XML直观
- 服务器返回JSON文件

```json
[{"id":"1","name":"name"},
 {"id":"2","name":"name2"}]
```

（1）使用JSONObject（官方提供）

```java
OkHttpClient client = new OkHttpClient();
Request request = new Request.Builder()
                    .url("http://...json")//通过uri设置网络地址
                    .build();
Response response = client.newCall(request).execute();//发送请求获取服务器返回的数据
String responseData = response.body().string();//得到返回的具体内容

try {
    JSONArray array = new JSONArray(responseData);//将服务器返回的数据传入一个JSONArray对象
    for (int i=0;i<responseData.length();i++){
        JSONObject object = array.getJSONObject(i);//JSONArray中每一个元素都是JSONObject对象，该对象又包含数据
        String id = object.getString("id");
        String name = object.getString("name");
    }
}catch (Exception e){
    e.printStackTrace();
}
```

（2）使用GSON（谷歌开源库）

- 添加GSON库的依赖： `implementation 'com.google.code.gson:gson:2.7'` 
- GSON可以将JSON格式的字符串映射成一个对象
- 首先创建一个Person类，加入id、name两个字段，加入set和get方法
- 将JSON数据解析成Person对象

```java
Gson gson = new Gson();
Person person = gson.fromJson(responseData, Person.class);
```

- 如果是JSON数组的话，借助TypeToken传入数据， `List<Person> list = gson.fromJson(responseData,new TypeToken<List<Person>>(){}.getType())` 
- 用法示例

```java
OkHttpClient client = new OkHttpClient();
Request request = new Request.Builder()
                    .url("http://...json")//通过uri设置网络地址
                    .build();
Response response = client.newCall(request).execute();//发送请求获取服务器返回的数据
String responseData = response.body().string();//得到返回的具体内容

Gson gson = new Gson();
List<Person> list = gson.fromJson(responseData,new TypeToken<List<Person>>(){}.getType());//将JSON数组解析成Person对象
for (Person person : list){
    ...//使用get方法获得相应字段
}
```

#### 5、网络编程最佳实践

- 通常应该将通用的网络操作封装到一个类里，提供一个静态的方法
- 网络请求通常都是耗时的操作，需要开一个子线程，使用Java的回调机制
- 回调机制

> 定义一个接口
>
> ```java
> public interface HttpCallbackListener{
> 	void onFinish(String response);//服务器成功响应时调用
> 	void onError(Exception e);//网络操作出现错误时调用
> }
> ```
>
> 网络操作公共类
>
> ```java
> public class HttpUtil {
> 	public static void sendHttpRequest(final String address,final HttpCallbackListener listener){
> 		new Thread(new Runnable() {
>     		@Override
>            	 public void run() {
>                	 HttpURLConnection connection = null;
>                	 try {
>                  	   ...
>                     	if (listener != null) {
>                         	//回调onFinish() 方法
>                         	listener.onFinish(response.toString);
>                     	}
>                 	}catch (Exception e){
>                     	if (listener != null){
>                         	//回调onError() 方法
>                         	listener.onError(e);
>                     	}
>                 	}finally {
>                     	if (connection != null){
>                         	connection.disconnect();
>                     	}
>                 	}
>             	}
>         	}).start();
>     	}
>     }
> ```
>
> 调用公共类
>
> ```java
> HttpUtil.sendHttpRequest(adress,new HttpCallbackListener(){
> 	@Override
> 	public void onFinish(String response){
> 		//根据返回内容执行具体逻辑
> 	}
> 	@Override
> 	public void onError(Exception e){
> 		//对异常进行处理
> 	}
> });
> ```

- 使用OkHttp

> okhttp3.Callback是OkHttp库自带的一个回调接口，类似于自己编写的HttpCallbackListener，然后调用一个enqueue() 方法，传入okhttp3.Callback参数，OkHttp在enqueue() 方法内部已经开好了子线程，会在子线程中执行HTTP请求，将结果回调到okhttp3.Callback中
>
> ```java
> public static void sendOkHttpRequest(String address, okhttp3.Callback callback){
> 	OkHttpClient client = new OkHttpClient();
> 	Request request = new Request.Builder()
>                     .url(address)
>                     .build();
> 	client.newCall(request).enqueue(callback);
> }
> ```
>
> 调用sendOkHttpRequest方法
>
> ```java
> HttpUtil.sendOkHttpRequest(adress,new okhttp3.Callback(){
> 	@Override
> 	public void onResponse(Call call,Response response) throws IOException {
> 		//根据返回内容执行具体逻辑
> 	}
> 	@Override
> 	public void onFailure(Call call,IOException e){
> 		//对异常进行处理
> 	}
> });
> ```

### 十、服务

- 服务（Service）是Android实现程序后台运行的解决方案，适合不需要和用户交互但要长期运行的任务
- 服务的运行不依赖任何界面，依赖与创建服务时所在的应用程序进程

####1、Android多线程编程

（1）线程基本用法

- 定义一个线程可以继承Thread类，重写run() 方法，调用其start() 方法即可运行；使用继承的方式耦合性有点高，更多时候选择实现Runnable接口来定义一个线程，还有更常见的使用匿名类的方法

```java
//继承方式
class MyThread extends Thread{
	@Override
	public void run(){
		//具体逻辑
	}
}
//启动方法
new MyThread().start();

//实现接口
class MyThread implements Runnable{
	@Override
	public void run(){
		//具体的逻辑
	}
}
//启动方法
MyThread myThread = new MyThread();
new Thread(myThread).start();

//匿名类方式
new Thread(new Runnable(){
    @Override
    public void run(){
        //具体逻辑
    }
}).start();
```

（2）在子线程中更新UI

- Android的UI也是线程不安全的，即更新UI必须在主线程中进行，否则会出现异常
- 异步消息处理

> 使用Handler对象，子线程调用Handler的sendMessage() 方法发送Message，主线程的Handler调用handleMessage() 方法处理Message

```java
//主线程
private final Handler handler = new Handler(new Handler.Callback() {
    @Override
    public boolean handleMessage(@NonNull Message msg) {
        switch (msg.what){
            case TEXT:
                //在这里进行UI操作
                break;
            default:break;
        }
        return false;
    }
});

//子线程
new Thread(new Runnable() {
    @Override
    public void run() {
        Message message = new Message();
        message.what = TEXT;
        handler.sendMessage(message);//将Message发送出去
    }
}).start();
```

（3）解析异步消息处理机制

- 由Message、Handler、MessageQueue、Looper组成

> Message 在线程之间传递消息，内部可以携带少量信息，上例使用了Message的what字段，此外还可以使用arg1和arg2字段携带整形数据，使用obj字段携带Object对象
>
> Handler（处理者），用于发送和处理消息，发送一般是Handler的sendMessage() 方法，发出的消息最终会传递到Handler的handleMessage() 方法中
>
> MessageQueue是消息队列，存储Handle发出的消息，每个线程中只会有一个MessageQueue对象
>
> Looper（管家）调用Looper的loop() 方法，会进入一个无限循环中，每当发现MessageQueue中存在一条消息，就会将其取出，并传递到Handler的handleMessage() 方法中，每个线程只有一个Looper对象

- 异步处理的流程

> 创建一个Handle对象，重写handleMessage() 方法，当子线程需要进行UI操作时，就创建一个Message对象，通过Handler将这条消息发送出去。之后这条消息会被添加到MessageQueue的队列中等待被处理，而Looper则会一直尝试从MessageQueue中取出待处理消息，最后分发回Handler的handleMessage() 方法中。由于Handler是在主线程中创建的，所以此时handleMessage() 方法中的代码也会在主线程中运行

<img src="Image.assets\异步回调.png" alt="异步回调" style="zoom: 67%;" />

- runOnUiThread() 方法是一个异步消息处理机制的接口封装，背后原理和上图一样

（4）使用AsyncTask

- AsyncTask是一个抽象类，继承时可以指定3个泛型参数

> Params 在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。
>
> Progress 后台任务执行时，如果需要在界面上显示当前的进度，则使用这个泛型作为进度单位。
> Result 任务执行完毕后，若需要对结果进行返回，使用这个泛型作为返回值类型。

```java 
class MyTask extends AsyncTask<Void,Integer,Boolean> {
	...
}
```

- 目前MyTask还需要重写AsyncTask中的几个方法

> onPreExecute() 方法会在后台任务开始执行之前调用，用于一些界面上的初始化操作
>
> doInBackground (Params...) 方法中的所有代码都会在子线程中运行，应该在这里去处理所有的耗时任务。任务完成通过return语句返回结果，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress... ) 方法来完成
>
> onProgressUpdate(Progress...) 在后台任务中调用了publishProgress(Progress...)方法后，该方法会被调用，该方法的参数是在后台任务中传递过来的。该方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。
>
> onPostExecute(Result) 后台任务执行完毕并通过return语句进行返回时，该方法会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。

```java 
class DownloadTask extends AsyncTask<Void,Integer,Boolean>{
	@Override
	protected void onPreExecute() {
		progressDialog.show(); //显示进度对话框
	}
    
	@Override
    protected Boolean doInBackground(Void... params) {
        //执行下载任务（在子线程中运行）
        try {
            while (true) {
                int downloadPercent = doDownload(); //虚构的方法.
                publishProgress(downloadPercent);//子线程不能进行UI操作，调用publishProgress()方法传入当前下载进度
                if (downloadPercent >= 100){
                	break;
                }
            }
    	} catch (Exception e) {
            return false;//下载失败
        }
        return true;//下载完成
    }
    
    @0verride
    protected void onProgressUpdate(Integer... values) {
    	//在这里更新下载进度
    	progressDialog.setMessage("Downloaded”+ values[0] +“%");
    }
    
    @Override
    protected void onPostExecute(Boolean result) {
        //在这里进行UI操作（在主线程中运行）
   		progressDialog.dismiss(); //关闭进度对话框
    	//在这里提示下载结果
    	if (result) {
    		Toast.makeText(context,"Download succeeded",Toast.LENGTH_ SHORT).show();
    	} else {
    		Toast.makeText(context,"Download failed",Toast.LENGTH_ SHORT).show();
        }
    }
}
```

- 使用总结

> 在doInBackground() 方法中执行具体的耗时任务，在onProgressUpdate() 方法中进行UI操作，在onPostExecute() 方法中执行任务的收尾工作。

- 启动任务， `new DownloadTask().execute()` 

#### 2、服务基本用法

（1）定义一个服务

- 在Android Studio中New一个Service，Exported属性表示是否允许其他程序访问，Enabled属性表示是否启用这个服务，可以看到新建的服务是继承自Service类的，里面有一个唯一的抽象方法onBind() 
- 重写onCreate() 、onStartCommand() 、onDestroy() 方法，onCreate() 在服务创建时（第一次）调用，而onStartCommand() 在每次启动服务时都会调用，onDestroy() 在服务销毁时调用（用来回收不再使用的资源）
- 每一个服务需在AndroidManifest.xml 文件中注册才能生效（<service> 标签）

```java 
public class MyService extends Service {
    ...
    @0verride
    public void onCreate() {
        super.onCreate();
        Log.d("MyService", "onCreate executed");
    }
    
    @0verride
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.d("MyService", "onStartCommand executed");
        return super.onStartCommand(intent, flags, startId);
    }
    
    @Override
    public void onDestroy() {
        super.onDestroy() ;
        Log.d("MyService", "onDestroy executed") ; 
    }
}
```

（2）启动和停止服务

- 借助Intent实现

```java
Intent intent = new Intent(this, MyService.class);
startService(intent);//启动服务
stopService(intent);//停止服务
```

- startService() 和stopService() 方法定义在Context类中，可以在活动中直接使用，服务自身可以调用stopSelf() 方法来停止服务

（3）活动和服务进行通信

- MyService类：自定义一个类继承自Binder，在内部提供方法（例如下载与查看进度），然后在MyService类中创建该类的实例，在onBind() 方法里返回该实例

```java
public class MyService extends Service {
    private DownloadBinder mBinder = new DownloadBinder();
    
    class DownloadBinder extends Binder {
        public void startDownload(){
       		Log.d("MyService", "startDownload executed");
        }
        public int getProgress() {
        	Log.d("MyService", "getProgress executed");
        	return 0;
        }
    }
    
    @0verride
    public IBinder onBind(Intent intent) {
    	return mBinder;
    }
}
```

- 活动中：创建一个ServiceConnection 的匿名类，重写onServiceConnected() 和onServiceDisconnected() 方法，这两个方法分别会在活动与服务成功绑定和解除绑定的时候调用。在onServiceConnected()方法中，通过向下转型得到了DownloadBinder的实例，可以调用DownloadBinder中的任何public 方法，实现了活动指挥服务的功能。
- 绑定与解绑服务：构建一个Intent对象，调用bindService() 方法将Activity和Service进行绑定。bindService() 方法接收3个参数，第一个参数就是刚构建的Intent对象，第二个参数是ServiceConnection的实例，第三个参数是一个标志位，传入 BIND_ AUTO_CREATE 表示在活动和服务进行绑定后自动创建服务。这会使得MyService中的onCreate() 方法得到执行，但onStartCommand() 方法不会执行。

```java
private MyService.DownloadBinder downloadBinder;

private ServiceConnection connection = new ServiceConnection() {
    //活动与服务解除绑定时调用
    @0verride
    public void onServiceDisconnected(ComponentName name){}
    
    //活动与服务成功绑定时调用
    @0verride
    public void onServiceConnected(ComponentName name, IBinder service) {
        downloadBinder = (MyService.DownloadBinder)service;
        downloadBinder.startDownLoad();
        downloadBinder.getProgress();
    }
};

//绑定服务
Intent bindIntent = new Intent(this, MyService.class);
bindService(bindIntent, connection, BIND_AUTO_CREATE);
//解绑服务
unbindService(connection); 
```

#### 3、服务的生命周期

- 调用Context的startService() 方法，相应的服务就会启动，并回调onStartCommand() 方法。如果该服务之前没有创建过，onCreate() 方法会先于onStartCommand() 方法执行。服务启动了之后会一直保持运行状态，直到stopService() 或stopSelf() 方法被调用。虽然每调用一次startService() 方法，onStartCommand() 方法就会执行一次，但每个服务只会存在一个实例。所以不管调用多少次startService() 方法，只需调用一次stopService() 或stopSelf()方法，服务就会停止下来。

- 当调用了startService() 方法后，又去调用stopService() 方法，服务中的onDestroy() 方法就会执行，表示服务已经销毁了。
  当调用了bindService() 方法后，又去调用unbindService() 方法，onDestroy()方法也会执行 。
  有可能对一个服务既调用了startService() 方法，又调用了bindService() 方法的，服务只要被启动或者被绑定了之后就会一直处于运行状态，必须要让以上两种条件同时不满足，服务才能被销毁。所以这种情况下要同时调用stopService() 和unbindService() 方法，onDestroy() 方法才会执行。
  
  ![第一行代码_Service生命周期](Image.assets\第一行代码_Service生命周期.png)

#### 4、服务更多技巧

（1）使用前台服务

- 前台服务和后台服务：前者在系统状态栏会一直有一个正在运行的图标，下拉可以看到详细信息，类似通知，前台服务可以防止被系统回收（服务的系统优先级较低）
- 创建前台服务：创建Notification对象后调研startForground() 方法，会让MyService变成一个前台服务，并在系统状态栏显示

```java
public class MyService extends Service {
    ...
    @0verride
    public void onCreate() {
        super.onCreate();

        Intent intent = new Intent(this, MainActivity.class);
        PendingIntent pi = PendingIntent.getActivity(this,θ,intent,θ);
        Notification notification = new NotificationCompat.Builder(this)
            .setContentTitle("title")
            .setContentText("text" )
            .setWhen(System.currentTimeMillis())
            .setSmallIcon(R.mipmap.ic_launcher)
            .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_Launcher))
            .setContentIntent(pi)
            .build();
        startForeground(1,notification);
    }
    ...
}
```

（2）使用IntentService

- 服务默认运行在主线程中，如果在服务里处理一些耗时操作，容易出现ANR（Application Not Responding），处理方法是在服务具体方法里开启一个子线程去处理耗时操作，实现服务执行完毕后自动停止可以在线程中调用stopSelf() 方法

```java
public class MyService extends Service {
    ...
    @Override
    public int onStartCommand(Intent intent,int flags,int startId) {
        new Thread (new Runnable() {
            @0verride
            public void run() {
            	//处理具体的逻辑
                stopSelf();
            }
        }).start();
        return super.onStartCommand(intent,flags,startId);
    }
}
```

- 为了简单地创建一个异步的、会自动停止的服务，Android 提供了一个IntentService类，先创建一个类继承IntentService，然后要提供一个无参的构造函数，并且必须在其内部调用父类的有参构造函数。然后要在子类中去实现onHandleIntent() 这个抽象方法，在这个方法中可以去处理一些具体的逻辑，不用担心ANR，因为这个方法已经是在子线程中运行的了。
  
```java
  public class MyIntentService extends IntentService {
      public MyIntentService() {
      	super( "MyIntentService"); //调用父类的有参构造函数
      }
      
      @0verride
      protected void onHandleIntent (Intent intent) {
          //打印当前线程的id
          Log.d("MyIntentService","Thread id is " + Thread. currentThread().getId());
      }
  }
```

### 十一、基于位置的服务

####1、简介

- 基于位置的服务（Location Based Service），简称LBS，主要原理是无线电通讯网络或者GPS等定位方式
- GPS工作原理是基于手机内置的GPS硬件直接和卫星交互，精度高，缺点是只能在室外使用
- 网络定位是根据手机当前的网络附近的三个基站进行测速，精度一般，但是室内外都能使用

#### 2、申请API Key

- 使用百度LBS功能需要申请一个API Key，访问http://lbsyun.baidu.com/apiconsole/key#/home，同意百度开发者协议，点击创建应用就可以申请API Key，应用类型是Android SDK，启动服务保持默认

- 发布版SHAI和开发板SHAI：打包程序的签名文件的SHAI指纹，填写的一个字段,它指的是打包程序时所用签名文件的SHA1指纹，可以通过Android Studio查看，点击右侧工具栏的Gradle，项目名，:app，Tasks，android，这里展示了一个Android Studio项目中所有内置的Gradle Tasks，其中signingReport这个Task就可以用来查看签名文件信息。双击signingReport，目前显示的是debug.keystore 文件生成的指纹，这是Android自动生成的一个测试的签名文件，当应用程序发布时还需要创建一个正式的签名文件，要得到指纹可以在cmd中输入： `keytool -list -V -keystore <签名文件路径>` ，输入密码即可

#### 3、使用百度定位

（1）准备LBS SDK

- 先将百度LBS开放平台的SDK准备好，下载地址：http://bsyun.baidu.com/sdk/download，下载完解压有一个libs目录，libs目录下的内容又分为两部分，BaiduLBS_ Android.jar 这个文件是Java层要使用到的，其他子目录下的so文件是Native层要用到的。so文件是用C/C++语言进行编写，然后再用NDK编译出来的，百度已经做好了封装。
- 将BaiduLBS_ Android.jar 文件放在app模块下的libs目录，这里用来存放所有的jar包，然后在src/main 目录下新建一个jniLibs 的文件夹，用来存放so 文件，把压缩包其他目录复制到这里吗，然后手动Sync

（2）确定经纬度

- AndroidManifest.xml文件：添加权限声明，每一个权限都是百度LBS SDK内部要用到的。然后在<application>标签的内部添加一个<meta-data>标签，该标签的android:name 部分是固定的，必须填com.baidu.lbsapi.API_KEY，android:value 部分应该填入APIKey。最后还需要再注册一个LBS SDK中的服务，百度LBS SDK中的代码都是混淆过的

```xml
<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
<uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/>
<uses-permission android:name="android.permission.READ_PHONE_STATE"/>
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
<uses-permission android:name="android.permission.INTERNET"/>
<permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/>
<uses-permission android:name="android.permission.WAKE_LOCK"/>

<application>
    <meta-data
    	android:name="com.baidu.lbsapi.API_KEY"
    	android:value="qQwDxyM9k2OIOFyNNxavjDvYa1DyVxHt"/>

    <service android:name="com.baidu.location.f"
    	android:enabled="true"
    	android:process=":remote">
    </service>
</application>
```

- 在onCreate() 方法中创建了一个LocationClient 实例，LocationClient的构建函数接收一个Context参数，调用getApplicationContext() 方法来获取一个全局的Context参数并传入。然后调用LocationClient的registerlocationListener() 方法来注册一个定位监听器，当获取到位置信息的时候，就会回调这个定位监听器。
  接下来是运行时权限，由于在AndroidManifest.xml中声明了很多权限，参考危险权限表格可以发现，其中ACCESS_COARSE_LOCATION、ACCESS_FINE_ L0CATION、READ_ PHONE_STATE、WRITE_EXTERNAL_STORAGE 这4个权限需要进行运行时权限处理，由于ACCESS_COARSE_LOCATION 和ACCESS_ FINE_ LOCATION 都属于同一个权限组，因此两者只要申请其一即可。一次性申请3个权限可以创建一个List集合，然后依次判断这3个权限是否被授权，没有就添加到List 集合中，最后将List 转换成数组，再调用ActivityCompat.requestPermissions() 方法一次性申请。在onRequestPermissionsResult() 方法中通过循环判断申请的每个权限，如果有任何一个权限被拒绝，就直接调用finish() 方法关闭当前程序，当所有权限都被用户同意了，才会调用requestLocation() 方法开始地理位置定位。requestLocation()方法中的代码比较简单,只是调用了一下LocationClient的start() 方法就能开始定位了。定位结果会回调到监听器MyLocationListener，在onReceiveLocation() 方法通过BDLocation 的getLatitude() 和getLongitude() 方法获取当前位置的纬度和经度，通过getLocType() 方法获取当前定位方式

```java
public LocationClient mLocationClient;
private TextView positionText;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mLocationClient = new LocationClient(getApplicationContext());
    mLocationClient.registerLocationListener(new MyLocationListener());//注册一个定位监听器，当获取到位置信息时会回调这个监听器
    setContentView(R.layout.activity_main);

    positionText = findViewById(R.id.position_text_view);
    List<String> permissionList = new ArrayList<>();//权限集合
    if (ContextCompat.checkSelfPermission(MainActivity.this, android.Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
        permissionList.add(android.Manifest.permission.ACCESS_FINE_LOCATION);
    }
    if (ContextCompat.checkSelfPermission(MainActivity.this, android.Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) {
        permissionList.add(android.Manifest.permission.READ_PHONE_STATE);
    }
    if (ContextCompat.checkSelfPermission(MainActivity.this, android.Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
        permissionList.add(android.Manifest.permission.WRITE_EXTERNAL_STORAGE);
    }
    if (!permissionList.isEmpty()) {
        String[] permissions = permissionList.toArray(new String[permissionList.size()]);
        ActivityCompat.requestPermissions(MainActivity.this, permissions, 1);
    } else {
        //所有权限被授权才调用
        requestLocation();
    }
}

private void requestLocation() {
    mLocationClient.start();//开始定位
}

@Override
public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    switch (requestCode) {
        case 1:
            if (grantResults.length > 0) {
                for (int result : grantResults) {
                    if (result != PackageManager.PERMISSION_GRANTED) {
                        Toast.makeText(this,"必须同意所有权限才能使用本程序",Toast.LENGTH_SHORT).show();
                        finish();
                        return;
                    }
                }
                requestLocation();
            } else {
                Toast.makeText(this, "发生未知错误", Toast.LENGTH_SHORT).show();
            }
            break;
        default:
    }
}

public class MyLocationListener extends BDAbstractLocationListener {
    @Override
    public void onReceiveLocation(BDLocation location) {
        StringBuilder currentPosition = new StringBuilder();
        currentPosition.append("纬度: ").append(location.getLatitude()).append("\n");//获取当前位置的纬度
        currentPosition.append("经线: ").append(location.getLongitude()).append("\n");//获取当前位置的经度
        currentPosition.append("定位方式: ");
        //获取当前定位方式
        if (location.getLocType() == BDLocation.TypeGpsLocation) {
            currentPosition.append("GPS");
        } else if (location.getLocType() == BDLocation.TypeNetWorkLocation) {
            currentPosition.append("网络");
        }
        positionText.setText(currentPosition);
    }
}
```

- 刷新定位：创建一个LocationClientOption对象，调用setScanSpan() 方法来设置更新的间隔。最后在活动销毁时调用LocationClient的stop() 方法来停止定位，不然程序会持续在后台进行定位，严重消耗手机的电量

```java
private void requestLocation() {
    initLocation();
    mLocationClient.start();
}

private void initLocation(){
    LocationClientOption option = new LocationClientOption();
    option.setScanSpan(5000);//每5秒钟会更新一下当前的位置
    mLocationClient.setLocOption(option);
}

@0verride
protected void onDestroy() {
    super.onDestroy();
    mLocationClient.stop();
}
```

（3）选择定位模式

- 有三种定位模式可以选择：Hight_Accuracy、Battery_Saving、Device_Sensors。Hight_Accuracy表示高精确度模式，也是默认的模式，会在GPS信号正常的情况下优先使用GPS定位，无法接收GPS信号时使用网络定位。Battery_Saving表示节电模式，只会使用网络定位。Device_Sensors表示传感器模式，只会使用GPS进行定位。使用传感器模式： 

```java 
LocationClientOption option = new LocationClientOption();
option.setLocationMode(LocationClientOption.LocationMode.Device_Sensors);
```

（4）易懂的位置信息

- 调用LocationClientOption的setIsNeedAddress() 方法，传入true，表示获取当前位置的详细地址。在MyLocationIistener的onReceiveLocation() 方法就可以获取到各种丰富的地址信息，调用getCountry() 方法可以得到当前所在国家，调用getProvince() 方法可以得到当前所在省份，以此类推。由于获取地址信息一定需要用到网络，因此即使将定位模式指定成了Device_Sensors，也会自动开启网络定位功能。

```java
pr1vate vo1d InitLocation() {
    LocationClientOption option = new LocationClientOption();
    option.setScanSpan (5000) ;
    option.setIsNeedAddress(true);
    mLocationClient.setLocOption(option);
}

public class MyLocationListener implements BDLocationListener {
    @0verride
    public void onReceiveLocation (BDLocation location) {
        StringBuilder currentPosition = new StringBuilder();
        currentPosition.append("国家: ").append(location.getCountry()).append("\n");
        currentPosition.append("省: ").append(location.getProvince()).append("\n");
        currentPosition.append("市: ").append(location.getCity()).append("\n");
        currentPosition.append("区: ").append(location.getDistrict()).append("\n");
        currentPosition.append("街道: ").append(location.getStreet()).append("\n");
    }
}

```

#### 4、使用百度地图

（1）显示地图

- 调用SDKInitializer的initialize() 方法来进行初始化操作，initialize() 方法接收一个Context参数，这里调用getApplicationContext() 方法获取一个全局的Context参数传入。注意初始化操作一定要在setContentView() 方法前调用，不然的话就会出错。接下来我们调用findViewById() 方法获取MapView的实例，重写onResume()、onPause()、onDestroy() 3个方法，对MapView进行管理，保证资源能够及时释放

```java
private MapView mapView;

@Override
protected void onCreate (Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mLocationClient = new LocationClient(getApplicationContext());
    mLocationClient.registerLocationListener(new MyLocationListener());
    SDKInitializer.initialize(getApplicationContext());
    //初始化操作一定要在setContentView()方法前调用
    setContentView(R.layout.activity_main);
    mapView = findViewById(R.id.bmapView) ;
}

@0verride
protected void onResume() {
    super.onResume();
    mapView.onResume();
}

@0verride
protected void onPause() {
    super.onPause();
    mapView.onPause();
}

@Override
protected void onDestroy() {
    super.onDestroy();
    mLocationClient.stop();
    mapView.onDestroy();
}
```

（2）移动到我的位置

- 百度LBS SDK提供一个BaiduMap类，是地图的总控制器，调用MapView的getMap() 方法就可得到BaiduMap实例
- 百度地图的缩放级别限制在3到19之间，小数点的值也可以取，值越大，地图信息越详细，MapStatusUpdateFactory的zoomTo() 方法接收一个float型的参数，用于设置缩放级别，该方法返回一个MapStatusUpdate对象，把该对象传人BaiduMap的animateMapStatus() 方法当中即可完成缩放功能

```java
BaiduMap baiduMap = mapView.getMap();
MapStatusUpdate update = MapStatusUpdateFactory.z00mTo(12.5f);//缩放级别为12.5
baiduMap.animateMapStatus(update);
```

- 移动到某一经纬度：借助LatLng类，该类主要用于存放经纬值，该类的构造接收两个参数，一个是纬度值，一个是经度值，之后调用MapStatusUpdateFactory 的newLatLng() 方法将LatLng对象传入，newLatLng() 方法返回一个MapStatusUpdate对象，再把该对象传入BaiduMap的animateMapStatus() 方法当中即可将地图移动到指定的经纬度上

```java
BaiduMap baiduMap = mapView.getMap();
LatLng 1l = new LatLng(39.915，116.404);
MapStatusUpdate update = MapStatusUpdateFactory.newLatLng(ll);
baiduMap.animateMapStatus(update);
```

- 完善代码

```java
private BaiduMap baiduMap;
private boolean isFirstLocate = true;

@Override
protected void onCreate (Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ...
    baiduMap = mapView.getMap();
    ...
}

private void navigateTo(BDLocation Location) {
    if (isFirstLocate) {
        LatLng ll = new LatLng(Location.getLatitude(), Location.getLongitude());
        MapStatusUpdate update = MapStatusUpdateFactory.newLatLng(ll);
        baiduMap.animateMapStatus(update);
        update = MapStatusUpdateFactory.zo0mTo(16f);
        baiduMap.animateMapStatus(update);
        isFirstLocate = false;
	}
}

public class MyLocationListener implements BDLocat ionListener {
    @Override
    public void onReceiveLocation( BDLocation location) {
        if (Location.getLocType() == BDLocation.TypeGpsLocation || Location.getLocType() == BDLocation.TypeNetWorkLocation) {
            navigateTo(Location);
        }
    }
}

```

（3）显示光标

- 百度LBS SDK提供一个MyLocationData.Builder类，该类用来封装设备当前
  所在位置，传入经纬度信息到该类相应方法中即可

```java
MyLocationData.Builder locationBuilder = new MyLocationData.Builder();
locationBuilder.latitude(39.915);
locationBuilder.longitude(116.404) ;
```

- MyLocationData.Builder类还提供一个build() 方法，封装的信息设置完成后，只需调用build() 方法，就生成一个MyLocationData的实例，然后将该实例传入BaiduMap的setMyLocationData() 方法中，即可让设备当前的位置显示在地图上

```java
MyLocationData locationData = locationBuilder.build();
baiduMap.setMyLocationData (locationData); 
```

- 完善代码：由于百度地图的限制，想要使用在地图上显示设备的位置这一功能，要先调用BaiduMap 的setMyLocationEnabled() 方法开启此功能

```java
@0verride
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    ...
    baiduMap.setMyLocationEnabled(true);
}

private void navigateTo(BDLocation location) {
    MyLocationData.Builder locationBuilder = new MyLocationData.Builder();
    locationBuilder.latitude(location.getLatitude());
    locationBuilder.lngitude(location.getLongitude());
    MyLocationData locationData = locationBuilder.build();
    baiduMap.setMyLocationData(locationData);
}

@Override
protected void onDestroy() {
    super.onDestroy();
    mLocationClient.stop();
    mapView.onDestroy();
    baiduMap.setMyLocationEnabled(false);
}

```

### 十二、Material Design实战

- Material Design是由谷歌的设计工程师基于传统优秀的设计原则，结合丰富的创意和科学技术发明的一套全新的界面设计语言，包含了视觉、运动、互动效果等特性
- 不少Material Design的效果很难实现，而Android中却几乎没有提供相应的API支持，于是谷歌在2015年推出了一个Design Support库，这个库将Material Design 中最具代表性的一些控件和效果进行了封装

#### 1、Toolbar

- ActionBar是系统原生控件，是顶部的标题栏
- Toolbar继承了ActionBar的所有功能，而且更灵活，可以搭配其他控件实现Material Design的效果
- ActionBar是根据项目中指定的主题来显示的，在AndroidManifest.xml文件下的<application>标签的android:theme 属性指定了一个AppTheme主题，该主题在res/values/styles.xml 中定义，打开该xml，这里定义了一个AppTheme主题，然后指定它的parent 主题是Theme.AppCompat.Light.DarkActionBar。DarkActionBar 是一个深色的ActionBar主题
- 使用Toolbar来替代ActionBar，需要指定一个不带ActionBar的主题，通常有Theme.AppCompat.NoActionBar和Theme.AppCompat.Light.NoActionBar两种主题可选，前者表示深色主题，它会将界面的主体颜色设成深色，陪衬颜色设成淡色；后者表示淡色主题，它会将界面的主体颜色设成淡色，陪衬颜色设成深色，
   `<style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">` 
- AppTheme中重写了colorPrimary、colorPrimaryDark和colorAccent3个属性的颜色。其中colorAccent属性不只是指定一个按钮的颜色，更多是表达一种强调，一些控件的选中状态也会使用colorAccent的颜色

<img src="Image.assets\各属性指定颜色.png" alt="各属性指定颜色" style="zoom: 67%;" />

- 在布局文件中使用xmlns:app指定一个新的命名空间， `xmlns:app="http://schemas.android.com/apk/res-auto"` 指定了xmlns :app，就可以使用app:attribute 这样的写法了。由于Material Design是在5.0系统出现的，而很多的Material属性在5.0之前的系统中并不存在，为了能够兼容老系统，不能使用android:attribute这样的写法，而是应该使用app:attribute
- 定义一个Toolbar控件，由于在styles.xml 中将程序的主题指定成淡色主题，因此Toolbar现在也是淡色主题，而Toolbar上面的各种元素会自动使用深色系，这是为了和主体颜色区分。为了能让Toolbar单独使用深色主题，可以使用android:theme属性，将Toolbar的主题指定成ThemeOverlay.AppCompat.Dark.ActionBar，但如果Toolbar中有菜单按钮，弹出的菜单项也会变成深色主题，这样会很难看，于是使用app:popupTheme属性单独将弹出的菜单项指定成了淡色主题。使用app : popupTheme可以兼容5.0以下的系统

```xml
xmlns:app="http://schemas.android.com/apk/res-auto"

<androidx.appcompat.widget.Toolbar
	android:id="@+id/toolbar"
	android:layout_width="match_parent"
	android:layout_height="?attr/actionBarSize"
	android:background="?attr/colorPrimary"
	android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
	app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/>
```

- 在代码中获取Toolbar实例，调用setSupportActionBar() 传入该实例，这样既使用了Toolbar，又使其外观和ActionBar一致

```java
Toolbar toolbar = findViewById(R.id.toolbar);
setSupportActionBar(toolbar);
```

- 在AndroidManifest.xml 中的<activity>标签内可以用 android:label属性指定Toolbar中显示的内容，没有指定默认使用application中的label，也就是应用名称
- 可以新建Menu resource的xml文件，使用<item>标签来定义action按钮，使用app命名空间： `o1ne-saJ/yde/w0o. pToupue' sewayps// :d124n=dde: su1wx` ，这里使用app命名空间是为了能够兼容低版本的系统，使用 app:showAsAction来指定按钮的显示位置，主要有以下几种值可选: always 表示永远显示在Toolbar中，如果屏幕空间不够则不显示；ifRoom表示屏幕空间足够的情况下显示在Toolbar中，不够的话就显示在菜单当中；never 则表示永远显示在菜单当中。其中，Toolbar 中的action按钮只会显示图标，菜单中的action按钮只会显示文字。

#### 2、滑动菜单

- 滑动菜单就是将一些菜单项隐藏起来，通过滑动的形式显示，节省空间

（1）DrawerLayout

- 这是一个布局，允许在该布局中放两个子控件，第一个子控件是主屏幕中显示的内容，第二个子控件是滑动菜单中显示的内容，第二个子控件的layout_gravity属性必须指定，因为需要告知DrawerLayout滑动菜单在左边还是右边，指定start系统会根据系统语言进行判断，系统语言从左往右就在左边，反之右边

```xml
<androidx.drawerlayout.widget.DrawerLayout
	xmlns:android="http://schemas.android.com/apk/res/android"
	xmlns:app="http://schemas.android.com/apk/res-auto"
	android:id="@+id/drawer_layout"
	android:layout_width="match_parent"
	android:layout_height="match_parent">
    
    <!--第一个子控件-->
    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">
        
        <androidx.appcompat.widget.Toolbar
            .../>
        
    </FrameLayout>
    
    <!--第二个子控件-->
    <TextView
        android:layout_gravity="start"
        .../>
    
</androidx.drawerlayout.widget.DrawerLayout>

```

- 加入导航按钮：

```java
private Drawerlayout mDrawerlayout;
@Override
protected void onCreate (Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Toolbar toolbar = findViewById(R.id.toolbar);
	setSupportActionBar(toolbar);
    mDrawerLayout = findViewById(R.id.drawer_layout);
    ActionBar actionBar = getSupportActionBar();//这个ActionBar具体是由ToolBar来完成的
    if (actionBar != null) {
        actionBar.setDisplayHomeAsUpEnabLed(true);//显示导航按钮
        actionBar.setHomeAsUpIndicator(R.drawable.ic_menu);//设置导航按钮图标，默认是一个返回的箭头
	}
}

@Override
public boolean onOptionsItemSelected (MenuItem item) {
    switch (item.getItemId()) {
        case android.R.id.home://HomeAsUp按钮点击事件
            //用openDrawer方法展示滑动菜单，传入一个Gravity参数，需要和XML中一致
        	mDrawerLayout.openDrawer(GravityCompat.START);break;
        default:break;
    }
    return true;
}

```

（2）NavigationView

- NavigationView 是Design Support库中提供的一个控件，不仅严格按照Material Design的要求设计，而且可以简化滑动菜单页面的实现
- 导入依赖： 第一行是Design Support库，第二行是开源项目CircleImageView，可以实现图片圆形化的功能

```java
implementation ' com.android.support:design:24.2.1'
implementation ' de.hdodenhof:circleimageview:2.1.0'
```

- 新建一个menu文件和一个布局，前者用在NavigationView中指定具体菜单项，后者显示头部布局，menu中<group>标签表示一个组，其中的checkableBehavior属性指定为single表示所有菜单项只能单选；然后布局文件的最外层是一个RelativeLayout，将其宽度设为match_ parent，高度设为180dp，这是一个NavigationView比较适合的高度，然后指定它的背景色为colorPrimary，其中的CirclelmageView是一个用于将图片圆形化的控件

```xml
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <group android:checkableBehavior="single">
        <item
            android:id= "@+id/nav_call"
            android:title="Call"/>
        <item
            android:id="@+id/nav_friends"
            android:title="Friends" />
        <item
            android:id="@+id/nav_location"
            android:title="Location"/>
        <item
            android:id="@+id/nav_mail"
            android:title="Mail"/>
        <item
            android:id="@+id/nav_task"
            android:title="Tasks"/>
    </group>
</menu>
```

```Xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="180dp"
    android:padding="10dp"
    android:background="?attr/colorPrimary">

    <de.hdodenhof.circleimageview.CircleImageView
        android:layout_width="70dp"
        android:layout_height="70dp"
        android:src="@drawable/ic_launcher_foreground"
        android:layout_centerInParent="true"/>

    <TextView
        android:id="@+id/username"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:text="陈宇"
        android:textSize="15sp"
        android:textColor="#171451"/>

</RelativeLayout>
```

- 在DrawerLayout的第二个子控件中通过app:menu和app:headerLayout属性将入菜单和头布局设置进去

```xml
<!--第二个子控件-->
    <com.google.android.material.navigation.NavigationView
        android:id="@+id/nav_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_gravity="start"
        app:menu="@menu/menu"
        app:headerLayout="@layout/nav_header"/>
```

- 在代码中处理点击事件，首先获取NavigationView 的实例，然后调用setCheckedItem() 方法将Call 菜单项设置为默认选中。接着调用了setNavigationItemSelectedListener() 方法设置菜单项选中事件的监听器，当点击了任意菜单项时，就会回调到onNavigationItemSelected() 方法中。这里只调用DrawerLayout的closeDrawers() 方法将滑动菜单关闭

```java
NavigationView navView = findViewById(R.id.nav_view);
navView.setCheckedItem(R.id.nav_call);
navView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {
    @Override
    public boolean onNavigationItemSelected(@NonNull MenuItem menuItem) {
        mLayout.closeDrawers();
        return true;
    }
});
```

#### 3、悬浮按钮和可交互提示

- 立面设计是Material Design中一条非常重要的设计思想，按照Material Design的理念，应用程序的界面不仅只是一个平面，而应该是有立体效果的。最简单且最具代表性的立面设计就是悬浮按钮，这种按钮不属于主界面平面的一部分，而是位于另外一个维度的，会给人一种悬浮的感觉。
- 关于提示工具，之前都是使用Toast，但是Toast只能用于告知用户某事情已经发生了，用户却不能对此做出任何的响应

（1）FloatingActionButton

- FloatingActionButton是Design Support库中提供的一个控件，这个控件可以比较轻松地实现悬浮按钮的效果。它默认使用colorAccent 来作为按钮的颜色
- 在DrawerLayout的第一个子控件中加入一个FloatingActionButton按钮，主页面显示的该按钮下面会有一些阴影，可以使用app:elevation属性来给FloatingActionButton 指定一个高度值，高度值越大，投影范围越大，但是投影效果越淡，反之相反
- 点击事件：和普通按钮一样都是调用setOnClickListener() 方法来注册一个监听器，点击按钮时执行监听器中的onClick() 方法

（2）Snackbar

- Toast 的作用是告诉用户现在发生了什么事情，但同时用户只能被动接收这个事情，没有办法能让用户进行选择。而Snackbar则在这方面进行了扩展，它允许在提示当中加入一个可交互按钮，当用户点击按钮的时候可以执行一些额外的逻辑操作，Snackbar的make() 方法的第一个参数是一个View，来自最外层布局，第二个是内容，第三个是时长，setAction() 方法设置一个动作，实现交互

```java
Snackbar.make(view,"text",Snackbar.LENGTH_SHORT).setAction("no", new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        //点击事件
    }
}).show();
```

- 弹出的Snackbar 提示会遮挡住悬浮按钮，可以使用CoordinatorLayout解决

（3）CoordinatorLayout

- CoordinatorLayout可以说是一个加强版的FrameLayout,这个布局也是由Design Support 库提供的。它在普通情况下的作用和FrameLayout基本一致，不过CoordinatorLayout可以监听其所有子控件的各种事件，然后自动做出响应。
- 上面弹出的Snackbar 提示会遮挡住悬浮按钮，而如果让CoordinatorLayout监听Snackbar的弹出事件，它会自动将内部的FloatingActionButton向上偏移，确保不会被挡
- 将DrawerLayout的第一个子控件改为CoordinatorLayout，在代码中的Snakebar的make() 方法的第一个参数View是FloatingActionButton本身，而FloatingActionButton又是CoordinatorLayout的子控件，所以该事件可以被CoordinatorLayout监听到

#### 4、卡片式布局

（1）CardView

- CardView是用于实现卡片式布局效果的重要控件，CardView实际上也是一个FrameLayout，只是额外提供了圆角和阴影等效果，看上去会有立体感，可以通过app:cardCornerRadius属性指定卡片圆角的弧度，数值越大，弧度越大，另外也可以使用app:elevation 属性指定卡片高度

```xml
<androidx.cardview.widget.CardView
	android:layout_width="match_parent"
	android:layout_height="wrap_content"
	app:cardCornerRadius="5dp"
	android:elevation="5dp">

    <TextView
		android:id="@+id/info"
		android:layout_width="match_parent"
		android:layout_height="wrap_content"
		android:background="#000"/>

</androidx.cardview.widget.CardView>
```

- Glide是一个超级强大的图片加载库，不仅可以用于加载本地图片，还可以加载网络图片、GIF 图片、甚至是本地视频。如果图片像素很高，Glide会自动压缩图片，不用担心内存溢出，最重要的是，Glide的用法非常简单，只需一行代码就能实现复杂的图片加载功能，导入依赖： `implementation 'com.github.bumptech.glide:glide:3.7.0'` 
- Glide用法：首先调用Glide. with() 方法并传入一个Context、Activity或Fragment参数，然后调用load() 方法载图片，可以是一个URL地址，也可以是一个本地路径，或者是一个资源id，最后调用into() 方法将图片设置到具体某个ImageView中即可

（2）AppBarLayout

- AppBarLayout是Design Support库中提供的工具，实际上是一个垂直方向的LinearLayout, 它在内部做了很多滚动事件的封装，并应用了一些Material Design的设计理念
- 在DrawerLayout的第一个子控件CoordinatorLayout下会出现遮挡Toorbar的情况，可以将Toorbar嵌套进AppBarLayout中，然后给下面的控件指定布局行为： `app:layout_behavior="@string/appbar_scrolling_view_behavior"` 
- AppBarLayout接收到滚动事件时，其内部子控件可以指定如何影响该事件，通过 `app:layout_scrollFlags` 属性实现，例如在Toolbar中写入 `app:layout_scrollFlags="scroll|enterAlways|snap"` ，scroll 表示当RecyclerView 向上滚动的时候，Toolbar 会跟着一起向上滚动并实现隐藏；enterAlways 表示当RecyclerView向下滚动的时候，Toolbar 会跟着一起向下滚动并重新显示；snap表示当Toolbar还没有完全隐藏或显示的时候，会根据当前滚动的距离，自动选择是隐藏还是显示。

#### 5、下拉刷新

- SwipeRefreshLayout是实现下拉刷新功能的核心类，把想要实现下拉刷新功能的控件放置到SwipeRefreshLayout 中，就可以迅速让这个控件支持下
  拉刷新
- 在代码中：首先通过findViewById() 方法获取SwipeRefreshLayout实例，然后调用setColorSchemeResources() 方法来设置下拉刷新进度条的颜色，这里使用主题中的colorPrimary的颜色。接着调用setOnRefreshListener() 方法设置一个下拉刷新的监听器，当触发下拉刷新操作的时候就会回调这个监听器的onRefresh() 方法，然后在这里处理具体的刷新逻辑
- 通常情况下，onRefresh() 方法中应该是去网络上请求最新的数据，然后再将这些数据展示出来。这里简单起见，调用一个refresh() 方法进行本地刷新操作。该方法中先开启一个线程，然后将线程沉睡两秒钟，因为本地刷新操作速度非常快，若沉睡线程，刷新立刻就结束了，从而看不到刷新过程。沉睡之后，使用runOnUiThread() 方法切换回主线程，然后调用SwipeRefreshLayout 的setRefreshing() 方法并传入false表示刷新事件结束并隐藏刷新讲度条

```java
private SwipeRefreshLayout mSwipeRefreshLayout;

mSwipeRefreshLayout = findViewById(R.id.swipe_refresh);
mSwipeRefreshLayout.setColorSchemeResources(R.color.colorPrimary);//设置下拉刷新进度条的颜色
//设置下拉刷新的监听器
mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
    @Override
    public void onRefresh() {
        refresh();
    }
});

private void refresh() {
    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                Thread.sleep(2000);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            //切换回主线程
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    Toast.makeText(DrawerLayoutTestActivity.this,"text",Toast.LENGTH_SHORT).show();
                    mSwipeRefreshLayout.setRefreshing(false);//刷新事件结束并隐藏刷新讲度条
                }
            });
        }
    }).start();
}
```

#### 6、可折叠式标题栏

（1）CollapsingToolbarLayout

- CollapsingToolbarLayout是一个作用于Toolbar基础之上的布局，是由Design Support库提供的。CollapsingToolbarLayout 可以让Toolbar的效果更加丰富，不过Collapsing ToolbarLayout不能独立存在，只能作为AppBarLayout的直接子布局来使用，而AppBarLayout又必须是CoordinatorLayout的子布局
- CollapsingToolbarLayout中的 app:contentScrim属性用于指定折叠之后的背景色，app:layout_scrollFlags属性指定为 scroll|exitUntilcollapsed ，scroll表示CollapsingToolbarLayout会随着内容一起滚动，exitUntilcollapsed表示CollapsingToolbarLayout滚动完折叠之后就保留在界面上
- 在CollapsingToolbarLayout 里两个子控件，app:layout_collapseMode 属性用于指定控件在CollapsingToolbarLayout折叠过程中的折叠模式，其中pin表示在折叠的过程中位置始终保持不变，parallax表示会在折叠的过程中产生一定的错位偏移
- NestedScrollView在ScrollView 的基础上增加了嵌套响应滚动事件的功能。由于CoordinatorLayout 可以响应滚动事件，因此在它的内部就需要使用NestedScrollView或RecyclerView这样的布局。ScrollView和NestedScrollView的内部都只允许存在一个直接子布局，在里面放入很多控件时通常先嵌套一个LinearLayout.，再放入控件
- FloatingActionButton 中使用app:layout_anchor 属性指定一个锚点AppBarLayout，这样悬浮按钮就会出现在AppBarLayout的区域内，接着又使用app:layout_anchorGravity属性将悬浮按钮定位在AppBarLayout区域的右下角

```xml
<android.support.design.widget.CoordinatorLayout
	xmlns:android="http://schemas.android.com/apk/res/android"
	xmlns:app="http://schemas.android.com/apk/res-auto"
	android:layout_width="match_parent"
	android:layout_height="match_parent">
	
    <android.support.design.widget.AppBarLayout
		android:id="@+id/appBar"
		android:layout_width="match_parent"
		android:layout_height="250dp">

        <android.support.design.widget.CollapsingToolbarLayout
			android:id="@+id/collapsing_toolbar"
			android:layout_width="match_parent"
			android:layout_height="match_parent"
			android:theme="@style/Theme0verlay.AppCompat.Dark.ActionBar"
			app:contentScrim="?attr/colorPrimary"
			app:layout_scrollFlags="scroll|exitUntilcollapsed">
            
            <ImageView
                android:id="@+id/fruit_image_view"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:scaleType="centerCrop"
                app:layout_collapseMode="parallax"/>
            
            <androidx.appcompat.widget.Toolbar
                android:id="@+id/toolbar"
                android:layout_width="match_parent"
                android:layout_height="?attr/actionBarSize"
                app:layout_collapseMode="pin"/>
            
		</android.support.design.widget.collapsingToolbarlayout>
                                     
	</android.support.design.widget.AppBarLayout>
    
    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent "
        app:layout_behavior="@string/appbar.scrolling_view_behavior">
        ...
        </androidx.core.widget.NestedScrollView>
    
    <android.support.design.widget.FloatingActionButton
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="16dp"
        android:src="@drawable/ic_comment"
        app:layout_anchor="@id/appBar"
        app:layout_anchorGravity="bottom|end"/>
                                     
</android.support.design.widget.CoordinatorLayout>
```

- 在代码中：在布局文件的NestedScrollView中加入控件使其能够滑动，滑动后会折叠标题栏

```java
@Override
protected void onCreate (Bundle savedIns tanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity);
    Toolbar toolbar = findViewById(R.id.toolbar);
    CollapsingToolbarlayout collapsingTooibar = findViewById(R.id.collapsing_toolbar);
    setSupportActionBar(toolbar);
    ActionBar actionBar = getSupportActionBar();
    if (actionBar != null) {
    	actionBar.setDisplayHomeAsUpEnabled(true);
    }
    collapsingToolbar.setTitle("title");//设置当前界面标题
	...
}
```

（2）充分利用系统状态栏空间

- 在Android 5.0系统之前，无法对状态栏的背景或颜色进行操作，那时也没有Material Design概念。但Android 5.0及之后的系统都支持这个功能，因此在Android 5.0及之后的系统中使用背景图和状态栏融合的模式，在之前的系统中使用普通的模式。让背景图和系统状态栏融合需借助android:fitsSystemWindows 属性。在CoordinatorLayout、AppBarLayout、 CollapsingToolbarLayout 这种嵌套结构的布局中，将控件的android:fitsSystemWindows属性指定成true，就表示该控件会出现在系统状态栏里
- 设置好android:fitsSystemWindows 属性还必须在程序的主题中将状态栏颜色指定成透明色。在主题中将android:statusBarColor属性的值指定成@android:color/transparent 就可以了。但问题在于android:statusBarColor 这个属性是从API 21，也就是Android 5.0系统开始才有的，之前的系统无法指定这个属性
- 在res目录下新建一个values-v21目录，在该目录下新建一个styles.xml文件，定义一个MyTheme主题，在该主题中将状态栏的颜色指定成透明色。values-v21目录的MyTheme主题的parent主题是AppTheme，继承了AppTheme中的所有特性。values-v21目录只有Android 5.0及以上的系统才会读取

```xml
<resources>

    <style name="MyTheme" parent="AppTheme">
        <item name="android:statusBarColor">@android:color/transparent</item>
    </style>

</resources>
```

- Android 5.0之前的系统无法识别values-v21下的主题，因此还需要对values/styles.xml 文件进行修改，在里面定义个同名主题，但什么也不用做：

```xml
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

    <style name="MyTheme" parent="AppTheme">
    </style>

</resources>
```

- 最后在AndroidManifest.xml 中的<activity> 标签中使用 `android:theme="@style/MyTheme"` 指定了该主题

### 十三、高级技巧

####1、全局获取Context技巧

- 弹出Toast、启动活动、发送广播、操作数据库、使用通知等等需要使用Context。很多操作都在活动中进行，而活动本身就是一个Context对象。但当应用程序的架构逐渐复杂起来时，很多逻辑代码都将脱离Activity类，但此时又恰恰需要使用Context
- Android提供了一个Application类，当应用程序启动的时，系统会自动将该类初始化。可以定制一个Application类，继承自Application，以便管理程序内一些全局的状态信息，比如说全局Context，一个项目只能配置一个Application

```java
public class MyApplication extends Application {
    private static Context context;
    
    @Override
    public void onCreate() {
    	context = getApplicationContext();//获得应用程序级别的Context
    }
    
    public static Context getContext() {
    	return context;
    }
}
```

- 告知系统，程序启动时初始化MyApplication类，而不是默认的Application类，在AndroidManifest.xml 文件的<application>标签下指定 `android:name="com.example.test.MyApplication"` ，这里要带完整的包名，在任何地方需要使用Context时只要调用一下MyApplication的getContex() 方法即可
- 如果自定义的Application和 LitePal 的LitePalApplication冲突了，只需要在自定义的Application中调用LitePal的初始化方法即可

####2、使用Intent传递对象

- 可以利用Intent来启动活动、发送广播、启动服务等等
- Intent使用putExtra() 方法添加传递的数据，但该方法支持的数据类型是有限的
- 使用Intent传递对象通常有两种方式：Serializable和Parcelable

（1）Serializable方式

- Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。序列化的方法只需要让一个类实现Serializable接口即可
- 例如Person类实现了Serializable接口，这样所有的Person对象都是可序列化的，传递该对象：

```java 
Person person = new Person;
Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
intent.putExtra("data", person);
```

- 接收该对象： `Person person = (Person)getIntent().getSerializableExtra("data")` 

（2）Parcelable方式

- 不同于将对象进行序列化，Parcelable 方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型
- 让一个类实现Parcelable接口，重写describeContents() 和writeToParcel() 方法，前者直接返回0，后者需要调用Parcel的writeXxx方法，整数类型就writeInt() 方法，以此类推。之外还必须在Person 类中提供一个名为CREATOR 的常量，实现Parcelable.Creator接口，将泛型指定为Person。接着重写createFromParcel() 和newArray() 两个方法，在createFromParcel() 方法中读取写出的name 和age 字段，并创建一个Person对象进行返回，其中name 和age 都是调用Parcel 的readXxx() 方法读取到的，读取顺序要和写出顺序完全相同。newArray() 方法中只需要new一个Person数组，并使用方法中传入的size作为数组大小即可

```java
public class Person implements Parcelable {
    private String name;
    private int age;
    
    @Override
    public int describeContents() {
    	return θ;
    }
    
    @0verride
    public void writeToParcel(Parcel dest, int flags) {
    	dest.writeString(name); // 写出name
    	dest.writeInt(age); // 写出age
    }
    
    public static final Parcelable.Creator<Person> CREATOR = new Parcelable.Creator<Person>() {
        
        @Override
        public Person createFromParcel(Parcel source) {
            Person person = new Person();
            person.name = source. readString(); // 读取name
            person.age = source. readInt(); // 读取age
            return person;
        }

        @0verride
        public Person[] newArray(int size) {
            return new Person[size];
        }
    };
}
```

- 可以用相同的代码传递Person对象，接收时的代码： `Person person = (Person)getParcelableExtra("data")` 

#### 3、定制日志工具

- 项目上线后调试的日志会照常打印，一行一行删除费时费力，且不利于维护，理想情况是开发阶段打印日志，上线后屏蔽
- 新建一个LogUtil类，可以将level的值指定为以上6个其中一个，当level值小于日志级别值时才会打印日志，level 等于NOTHING时就可以屏蔽所有日志，使用该类打印日志： `LogUtil.d("Tag","log");` 

```java
public class LogUtil {
    public static final int VERBOSE = 1;
    public static final int DEBUG = 2;
    public static final int INFO = 3;
    public static final int WARN = 4;
    public static final int ERROR = 5;
    public static final int NOTHING = 6;
    public static int level = VERBOSE;
    
    public static void v(String tag, String msg) {
        if (level <= VERBOSE) {
            Log.v(tag，msg);
        }
    }
        
    public static void d(String tag, String msg) {
        if (level <= DEBUG) {
            Log.d(tag, msg);
        }   
    }
    
    public static void i(String tag, String msg) {
        if (level <= INFO) {
        	Log.i(tag, msg);
        }
    }
    
    public static void W(String tag, String msg) {
        if (level <= WARN) {
        	Log.W(tag, msg);
        }
    }
    
    public static void e(String tag, String msg) {
        if (level <= ERROR) {
        	Log.e(tag, msg);
        }
    }
}
```

#### 4、调试Android程序（使用Android Studio）

- 添加断点：在相应代码左边点击即可
- 顶部工具栏Debug按钮会启动调试模式，会自动打开Debug窗口，每按一下F8键，代码向下执行一行，通过Variables视图可以看到内存中的数据
- 动态调试：正常启动程序，点击工具栏的Attach debugger to Android process按钮，会弹出一个提示框，选中当前进程就可以进入调试模式

#### 5、创建定时任务

- Android中的定时任务一般有两种实现方式，一种是使用Java API提供的Timer类，一种是使用Android的Alarm机制。Timer的短板是不太适用于那些需要长期在后台运行的定时任务。为了能让电池更加耐用，每种手机都会有自己的休眠策略，Android 手机会在长时间不操作的情况下自动让CPU进入睡眠状态，这有可能导致Timer中的定时任务无法正常运行。而Alarm具有唤醒CPU的功能，它可以保证在大多数情况下需要执行定时任务的时候CPU都能正常工作。这里唤醒CPU和唤醒屏幕完全不是一个概念

（1）Alarm机制

- 借助了AlarmManager类来实现的。该类和NotificationManager类似，都是通过调用Context的getSystemService() 方法来获取实例，只是这里需要传入的参数是Context.ALARM_SERVICE。获取AlarmManager 实例可以写成：
   `AlarmManager manager = (AlarmManager)getSystemService(Context.ALARM_SERVICE);` 
- 调用set() 方法设置一个定时任务，传入三个参数，

> 第一个是整型，指定AlarmManager的工作类型，有四种选择，ELAPSED_REALTIME 、ELAPSED_REALTIME_WAKEUP、RTC、RTC_WAKEUP。ELAPSED_REALTIME表示让定时任务的触发时间从系统开机开始算起，但不会唤醒CPU；ELAPSED_REALTIME_WAKEUP 表示让定时任务的触发时间从系统开机开始算起，但会唤醒CPU；RTC表示让定时任务的触发时间从1970年1月1日0点开始算起，但不会唤醒CPU；RTC_WAKEUP表示让定时任务的触发时间从1970年1月1日0点开始算起，但会唤醒CPU。使用SystemClock.elapsedRealtime() 方法可以获取到系统开机至今所经历时间的毫秒数，使用System.currentTimcMillis() 方法可以获取到1970年1月1日0点至今所经历时间的毫秒数
>
> 第二个参数是任务触发的时间，毫秒为单位，如果第一个参数使用的是ELAPSED_REALTIME或ELAPSED_REALTIME_WAKEUP，这里传入开机至今的时间再加上延迟执行的时间。如果第一个参数使用的是RTC或RTC_WAKEUP，这里传入1970年1月1日0点至今的时间再加上延迟执行的时间
>
> 第三个参数是一个PendingIntent，这里一般调用getService() 方法或者getBroadcast() 方法获取一个能够执行服务或广播的PendingIntent。当定时任务被触发时，服务的onStartCommand() 方法或广播接收器的onReceive()方法就可以得到执行
>
> 设置任务10秒钟后执行：

```java
long triggerAtTime = SystemClock.elapsedRealtime() + 10 * 1000;
manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP，triggerAtTime，pendingIntent);
```

```java
long triggerAtTime = System.currentTimeMillis() + 10 * 1000;
manager.set(AlarmManager.RTC WAKEUP,triggerAtTime,pendingIntent);
```

- 设定长时间在后台定时运行的服务：首先新建一个普通服务，触发定时任务的代码写到onStartCommand() 方法中，在该方法中开启子线程执行耗时的逻辑操作，

```java
public class LongRunningService extends Service {
    @0verride
    public IBinder onBind (Intent intent) {
    	return null;
    }
    
    @0verride
    public int onStartCommand(Intent intent, int flags, int startId) {
        new Thread (new Runnable() {
            @0ver ride
            public void run() {
            	//在这里执行具体的逻辑操作
            }
        }).start();
        AlarmManager manager = (AlarmManager)getSystemService (ALARM_SERVICE);
        int anHour = 60 * 60 * 1000; //这是一小时的毫秒数
        long triggerAtTime = SystemClock.elapsedRealtime() + anHour;
        Intent i = new Intent(this,LongRunningService.class);
        PendingIntent pi = PendingIntent.getService(this, 0, i, 0);
        manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi); 
        return super.onStartCommand(intent, flags, startId);
    }
}
```

- 启动服务：

```java
Intent intent = new Intent(context, LongRunningService.class);
context.startService(intent);
```

- 从Android 4.4系统开始，Alarm任务的触发时间会变得不准确，可能会延迟一段时间后才执行。这不是bug，而是系统在耗电性方面进行的优化。系统会自动检测目前有多少Alarm任务存在，然后将触发时间相近的几个任务放在一起执行，这可以大幅减少CPU被唤醒的次数，从而有效延长电池的使用时间。若Alarm任务的执行时间必须准确无误，使用AlarmManager 的setExact() 方法来替代set() 方法，就基本上可以保证任务准时执行

（2）Doze模式

- 虽然Android的每个系统版本都在手机电量方面努力优化，不过一直没能解决后台服务泛滥、手机电量消耗过快的问题。于是在Android 6.0系统中，谷歌加入了一个Doze模式，可以极大幅度延长电池的使用寿命
- 在Android 6.0或以上系统时，如果设备未接电源，处于静止状态(Android 7.0删除了这一条件)，且屏幕关闭了一段时间之后，就会进入Doze模式。在该模式下，系统会对CPU、网络、Alarm等活动进行限制，从而延长电池的使用寿命。系统不会一直处于 Doze模式，会间歇性退出Doze模式一小段时间去完成它们的同步操作、Alarm 任务等

<img src="Image.assets\Doze工作.png" alt="Doze工作" style="zoom: 50%;" />

- 设备进人Doze模式的时间越长，间歇性退出Doze模式的时间间隔也会越
  长。因为设备长时间不使用时没必要频繁退出Doze模式来执行同步等操作，Android在这些细节上的把控使电池寿命进一步延长
- Doze模式下被限制的功能

> 网络访问被禁止
>
> 系统忽略唤醒CPU或者屏幕操作
>
> 系统不再执行WIFI扫描
>
> 系统不再执行同步服务
>
> Alarm任务将会在下次退出Doze模式的时候执行，也就是说在Doze模式下，Alarm任务将变得不准时，可以调用AlarmManager的setAndAllowWhileIdle() 或setExactAndAllowWhileIdle() 方法让定时任务在Doze模式下也能正常执行了，这两个方法的区别和set()、setExact()方法之间的区别一样

#### 6、多窗口编程模式

- Android 7.0系统引入了多窗口模式，允许在同一个屏幕中同时打开两个应用程序

（1）进入多窗口模式

- 手机导航栏按钮：back、home、overview
- 在Overview列表界面长按任意一个活动的标题，将该活动拖动到屏幕突出显示的区域可以进入多窗口模式
- 打开任意一个程序，长按Overview按钮，也可以进人多窗口模式
- 屏幕被分成上下两部分（在横屏下左右分屏），overview按钮的样式也发生变化
- 长按overview按钮或者将中间分割线向屏幕一边拖到底即可退出多窗口模式

（2）多窗口下的生命周期

- 多窗口模式不会改变活动原有生命周期，只会将最近交互过的那个活动设置为运行状态，而将多窗口模式下另一个可见的活动设置为暂停状态。若暂停的活动交互，则该活动变成运行状态，之前处于运行状态的活动变成暂停状态
- 进入多窗口模式时活动会被重新创建，不重新创建可以在AndroidManifest.xml 中对该活动配置： `android:configChanges="orientation|keyboardHidden|screenSize|screenLayout"` ，加入该配置后横竖屏切换和进入多窗口模式活动都不会重新创建，而是会将屏幕变化的事件通知到Activity的onConfigurationChanged() 方法当中，若想在屏幕发生变化时进行相应的逻辑处理，可以在活动中重写onConfigurationChanged() 方法

（3）禁用多窗口模式

- 多窗口模式虽然功能非常强大，但未必适用于所有程序，比如说手机游戏
- 在AndroidManifest.xml 中的<application>或<activity>标签中加入属性： `android:resizeableActivity=["true"|"false"]` ，true 表示应用支持多窗口模式，false表示应用不支持多窗口模式，不配置该属默认值为true，但该属性只有项目的targetSdkVersion指定为24以及更高时才有用，否则无效
- Android规定若项目指定的targetSdkVersion低于24，且活动不允许横竖屏切换，则该应用也不支持多窗口模式。默认情况下，应用都可以随着手机的旋转自由横竖屏切换，若让应用不允许横竖屏切换，则在AndroidManifest.xml的<activity>标签中加入如下配置： `android:screen0rientation=["portrait"|"landscape" ]` ，portrait 表示活动只支持竖屏，landscape 表示活动只支持横屏。该属性中还有很多其他可选值，最常用是portrait和landscape

#### 7、Lambda表达式

- Java 8引入了一些功能，如Lambda表达式、streamAPI、接口默认实现等。这几个Java 8的新特性能够立即应用到项目当中的只有Lambda表达式，因为stream API和接口默认实现等特性都只支持Android 7.0及以上的系统，不可能为了使用这些新特性而放弃兼容众多低版本的Android手机。而Lambda表达式最低兼容到Android2.3系统，基本上可以覆盖所有的Android手机
- Lambda表达式本质上是一种匿名方法，没有方法名，也没有访问修饰符和返回值类型，使用其编写代码更加简洁，也加易读。若在Android项目中使用Lambda表达式或者Java 8的其他新特性，需要在app/build.gradle中添加如下配置：

```java
android {
    defaultConfig {
        ...
    	jackOptions.enabled = true
    }
    compile0ptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    ...
}
```

- Lambda开启子线程：

```java
//旧写法
new Thread( new Runnable() {
    @Override
    public void run() {
    	//处理具体的逻辑
    }
}).start();
//Lambda表达式
new Thread(() -> {
	//处理具体的逻辑
}).start();

```

### 十四、其他

#### 1、生成正式签名的APK文件

- Android 系统要求只有签名后的APK文件才可以安装，Android Studio使用了一个默认的keystore文件帮我们自动进行了签名。在Android Studio右侧工具栏的Gradle→项目名→:app→Tasks→android， 双击signingReport，所有通过Android Studio来运行的程序都是使用此debug.keystore 文件进行签名。不过仅仅适用于开发阶段

（1）使用Android Studio生成正式签名的APK文件

- 点击Android Studio导航栏的Build→Generate Signed APK，新建一个keystore文件，在Validity一栏填写的是keystore文件的有效时长，单位是年，一般建议填得长一些，比如30年

（2）使用Gradle生成

- Gradle用Groovy语言编写的，Android主要用Gradle来构建项目
- 在app/build.gradle中的android闭包添加signingConfigs闭包，在signingConfigs闭包中添加了一个config闭包。在config闭包中配置keystore文件的各种信息，storePile 用于指定keystore 文件的位置，storePassword 用于指定密码，keyAlias 用于指定别名，keyPassword用于指定别名密码

```groovy
signingConfigs {
    config {
        storeFile file('C:/Users/Administrator/Documents/guolin.jks')
        storePassword '1234567'
        keyALias 'guolindev'
        keyPassword '1234567'
    }
}
```

- 在android闭包的buildTypes下的release闭包中应用了刚才添加的签名配置： `signingConfig signingConfigs.config` ，生成正式版APK文件时会自动使用刚才配置的签名信息进行签名。
- Android Studio中内置了很多的Gradle Tasks，包括了生成APK文件的Task。点击右侧工具栏的Gradle→项目名→:app→Tasks→build，其中assembleDebug用于生成测试版的APK文件，assembleRelease 用于生成正式版的APK文件，assemble用于同时生成测试版和正式版的APK文件。在生成APK之前，先要双击clean这个Task来清理当前项目，然后双击assembleRelease，提示BUILD SUCCESSFUL说明assembleRelease 执行成功了。APK文件会自动生成在app/build/outputs/apk目录下，其中apprelease.apk是带有正式签名的APK文件。app releaseunaligned.apk是没有经过对齐的正式版APK文件，直接忽略即可。
- 目前keystore文件的所有信息都是以明文形式直接配置在build.gradle中的，这样不太安全。Android推荐的做法是将这类敏感数据配置在一个独立的文件里面，然后再在build.gradle中去读取这些数据。Android Studio项目根目录下的gradle.properties文件，专门用来配置全局键值对数据，在gradle.properties文件中添加：

```groovy
KEY_PATH=C:/Users/Administrator/Documents/guolin.jks
KEY_PASS=1234567
ALIAS_NAME=guolindev
ALIAS_PASS=1234567
```

- 这里将keystore文件的各种信息以键值对的形式进行配置，然后在build.gradle中去读取这些数据即可，只需将gradle.properties文件保护好即可，例如移除Git版本控制。编辑app/build.gradle 文件：

  ```groovy
  android {
      signingConfigs {
          configt {
              storeFile file(KEY_PATH)
              storePassword KEY_PASS
              keyAlias ALIAS_NAME
              keyPassword ALIAS_PASS
          }
      }
  }
  ```

（3）生成多渠道APK文件

- 在大多数情况下只需一个APK文件就够了，目前Android领域的应用商店非常多，不像苹果只有一个App.Store。可以使用同一个APK文件来上架不同的应用商店，但如果有一些特殊需求，比如针对不同的应用商店渠道定制不同的界面，传统情况下开发这种差异性需求通常需要维护多份代码版本，然后逐个打成相应渠道的APK文件。有功能变更时每份代码版本里面都需要逐个修改一遍。
- 生成多渠道APK文件：修改app/build.gradle，在android闭包下添加一个productFlavors闭包，在该闭包中添加所有的渠道配置就即可。Gradle中的配置不能以数字开头，qihoo表示360，baidu是百度，渠道名的闭包中可以覆写defaultConfig中的任何一个属性， 比如说这里将applicationId属性进行了覆写，最终生成的各渠道APK文件的包名也将各不相同

```groovy
productFlavors {
    qihoo {
        applicationId "com.coolweather.android.qihoo"
    }
    baidu {
        applicationId "com.coolweather.android.baidu"
    }
}
```

- 接下来针对不同渠道编写差异性需求，在app/src 目录下(main的平级目录)新建一个baidu目录，然后在baidu目录下再新建java和res两个目录，可以在这里编写百度渠道特有的功能，java目录用于存放代码，res 目录用于存放资源，如果需要覆写AndroidManifest 文件中的内容，还可以在baidu 目录下再新建一个AndroidManifest.xml文件。应用名之前是定义在main/es/values/string.xml文件中的，在baidu目录下也建立一个相同的目录结构，然后将baidu/res/values/string.xml 中修改应用名称，这样百度渠道的APK就会覆盖原来的应用名，360qihoo同理
- 生成多渠道APK文件：观察右侧工具栏的Gradle Tasks列表，发现里面多出几个新的Task，如果只想生成百度渠道的APK文件，就执行assembleBaidu；如果只想生成360渠道的APK文件，就执行assembleQihoo；如果想一次性生成所有渠道的APK文件，还是执行assembleRelease
- 除了使用Gradle的方式生成之外，使用Android Studio提供的可视化工具也能生成多渠道APK文件，这里可以选择生成百度渠道的APK文件还是360渠道的APK文件，若想一次性生成多个渠道的APK文件，按住CTRL键可以进行多选，接下来可以通过adb install 命令将生成好的APK文件安装到模拟器上