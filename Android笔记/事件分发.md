### 事件分发

<img src="https://img-blog.csdn.net/20151219223049372" alt="这里写图片描述" style="zoom:67%;" />

- Activity - ViewGroup - View，从外向内依次调用 dispatchTouchEvent 方法，Android 依次把 MotionEvent 参数传给该方法。dispatchTouchEvent 的作用是传递触摸事件。将触摸事件从外向内逐级传递派发，dispatchTouchEvent 是每次传递触摸事件的入口
- View - ViewGroup - Activity，从内向外依次调用 onTouchEvent 方法，Android 依次把 MotionEvent 参数传给该方法。onTouchEvent 的作用是处理触摸事件。将触摸事件从内向外逐级处理

#### 1、Activity

- dispatchTouchEvent：所有 UI 上的触摸操作生成的触摸事件会先触发 Activity 中 dispatchTouchEvent 方法

  ```java
  public boolean dispatchTouchEvent(MotionEvent ev) {
      if (ev.getAction() == MotionEvent.ACTION_DOWN) {
          onUserInteraction();
      }
      if (getWindow().superDispatchTouchEvent(ev)) {
          return true;
      }
      return onTouchEvent(ev);
  }
  ```

  > Activity 先通过 `getWindow()` 获取当前 window 对象（返回一个 PhoneWindow 类型实例），调用 window 的 superDispatchTouchEvent 方法，会调用 PhoneWindow 的 superDispatchTouchEvent 方法

  ```java
  @Override
  public boolean superDispatchTouchEvent(MotionEvent event) {
      return mDecor.superDispatchTouchEvent(event);
  }
  ```

  > mDecor 是 PhoneWindow 中一个 DecorView 类型变量，DecorView 代表当前 Window 最顶级 View（根View）。然后执行 DecorView 的 superDispatchTouchEvent 方法

  ```java
  public boolean superDispatchTouchEvent(MotionEvent event) {
      return super.dispatchTouchEvent(event);
  }
  ```

  > DectorView 继承自 FrameLayout，间接继承自 ViewGroup，DectorView 执行父类 ViewGroup 对应的 dispatchTouchEvent 方法
  >
  > 该方法中，DectorView 会找到其触摸的子节点（ViewGroup），然后执行该 ViewGroup 的 dispatchTouchEvent 方法，实现将触摸事件参数 MotionEvent 从 Activity 传入 DecorView 子 ViewGroup 中

- superDispatchTouchEvent 和 dispatchTouchEvent 方法均返回一个 boolean 类型的参数，true 表示触摸事件被处理，如果 PhoneWindow 的 superDispatchTouchEvent 返回 true，Activity 的 dispatchTouchEvent 直接返回 true，表明触摸事件被 Window 处理，不会执行 Activity 的 onTouchEvent 方法。只有 Window 没处理触摸事件，Activity 才会调用 onTouchEvent 方法处理

  ```java
  public boolean onTouchEvent(MotionEvent event) {
      if (mWindow.shouldCloseOnTouch(this, event)) {
          finish();
          return true;
      }
      return false;
  }
  ```

  > 当触摸事件没有被任何 View 或 ViewGroup 处理时，Activity 才会执行自己的 onTouchEvent 处理
  >
  > PS：当前触摸点在 Window 范围外，这样 Window 里所有 View 都不会接收更不会处理该触摸事件，这时可重写该方法实现逻辑处理，处理就返回 true，否则返回 false，默认实现基本一直返回 false

#### 2、ViewGroup

- dispatchTouchEvent：

  - Activity 收到触摸事件后，通过 DectorView 调用 ViewGroup 的 dispatchTouchEvent 方法（ViewGroup 对触摸事件进行处理的入口）
  - ViewGroup 定义一个 TouchTarget 类型的成员变量 mFirstTouchTarget 用于保存当前 ViewGroup 中处理触摸事件的子 View
  - dispatchTouchEvent 调用自身 onInterceptTouchEvent 方法（拦截 ViewGroup 将触摸事件传给子 View，返回 true 表示 ViewGroup 拦截触摸事件，false 表示不拦截，将触摸事件传给子 View），dispathTouchEvent 定义一个 boolean 类型 handled 变量用于保存 dispathTouchEvent 返回值
  - onInterceptTouchEvent 返回 false，ViewGroup 才会依次遍历子 View，通过 isTransformedTouchPointInView 方法判断 MotionEvent 触摸事件坐标是否落在子 View 范围内，在范围内 ViewGroup 把触摸事件坐标及子 View 传给 dispatchTransformedTouchEvent 方法，该方法调用子 View 的 dispatchTouchEvent 方法，返回值表示 View 是否处理触摸事件，dispatchTransformedTouchEvent 返回 true 表示子 View 处理触摸事件，ViewGroup 通过 addTouchTarget 将 mFirstTouchTarget 绑定子 View，且变量 alreadyDispatchedToNewTouchTarget 设 true 表示有子 View 处理触摸事件。有子 View 处理触摸事件 ViewGroup 通过 break 跳出子 View 遍历 for 循环
  - 对子 View for 循环后，没有子 View 处理触摸事件，mFirstTouchTarget 是 null，ViewGroup 将 null 作为 child 参数传入 dispatchTransformedTouchEvent 方法中，该方法调用 super.dispatchTouchEvent 方法，ViewGroup 继承自 View，相当执行 View 类的 dispatchTouchEvent 方法，可能会执行 ViewGroup 从 View 中继承来的 onTouchEvent 方法。dispatchTransformedTouchEvent 的返回值作为局部变量 handled
  - 对子 View for 循环后某个子 View 处理触摸事件，alreadyDispatchedToNewTouchTarget 是 true，将局部变量 handled 设为 true，表示只要有子 View 处理触摸事件，当前 ViewGroup 也处理触摸事件，ViewGroup 不会调用从 View 继承的 dispatchTouchEvent 方法，不触发 ViewGroup 的 onTouchEvent 方法执行

- onInterceptTouchEvent：用于拦截 ViewGroup 向子 View 传递触摸事件，默认实现一直返回 false，表示不拦截

- dispatchTransformedTouchEvent

  ```java
  private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,View child, int desiredPointerIdBits){
      final boolean handled;
      final MotionEvent transformedEvent;
      //......        
      // 执行任何必要的转换和调度
      if (child == null) {
          handled = super.dispatchTouchEvent(transformedEvent);
      } else {
          final float offsetX = mScrollX - child.mLeft;
          final float offsetY = mScrollY - child.mTop;
          transformedEvent.offsetLocation(offsetX, offsetY);
          if (! child.hasIdentityMatrix()) {
              transformedEvent.transform(child.getInverseMatrix());
          }
          handled = child.dispatchTouchEvent(transformedEvent);
      }
      // Done.
      transformedEvent.recycle();
      return handled;
  }
  ```
  > 将 MotionEvent 的 x、y 坐标转换成所传入 child 变量指定 View 的坐标系坐标，
  >
  > transformedEvent：已完成指定坐标系转换的 MotionEvent，如果传入 child 是 null，表示传入当前 ViewGroup，直接调用 `super.dispatchTouchEvent(transformedEvent)`，让 ViewGroup 调用父类 View 的 dispatchTouchEvent 方法；如果不是 null，表示传入当前 ViewGroup 一个子 View，会调用 `child.dispatchTouchEvent(transformedEvent)`，将触摸事件从 ViewGroup 传到子 View 中

- onTouchEvent
  
  - ViewGroup 的 onTouchEvent 继承自 View 的 onTouchEvent 方法，ViewGroup 没有重写

#### 3、View

- dispatchTouchEvent：View处理触摸事件的入口

  ```java
  public boolean dispatchTouchEvent(MotionEvent event) {
      //......
      boolean result = false;
      //......
      if (onFilterTouchEventForSecurity(event)) {
          //无检验简化If语句
          ListenerInfo li = mListenerInfo;
          //如果设置OnTouchListener，在此处执行OnTouchListener的onTouch方法
          if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
              //如果OnTouchListener的onTouch方法返回true，表示触摸事件被处理，result会设为true
              result = true;
          }
          //如果触摸事件没被OnTouchListener处理，执行View的onTouchEvent方法
          if (!result && onTouchEvent(event)) {
              //如果onTouchEvent返回true，表示触摸事件被View处理，result被设为true
              result = true;
          }
      }
      //......
      return result;
  }
  ```
  > View 先查看其有没有设过 OnTouchListener，设过就调用 OnTouchListener 的 onTouch 方法，返回 true 表明触摸事件被处理，result 设为 true。没有被处理会执行 View 的 onTouchEvent 方法，如果 onTouchEvent 返回 true，表示触摸事件被 View 处理，result 设为 true
  >
  > dispatchTouchEvent 方法先执行 OnTouchListener 的 onTouch 方法，返回 true 就不会调用 View 的 onTouchEvent 方法，只有 OnTouchListener 没有处理触摸事件才会执行 View 的 onTouchEvent 方法

- onTouchEvent

  - `View.onTouchEvent()` 方法中，如果 View 注册了 CLICK 或 LONG_CLICK 等事件监听器，会让注册的事件监听器处理触摸事件，onTouchEvent 返回 true。根据 ACTION 不同执行不同处理，如 ACTION_UP 会执行 `performClick()` 方法，该方法会触发 `OnClickListener.onClick()` 执行
  - 如果 View 没注册任何 CLICK 或 LONG_CLICK 等事件监听器，onTouchEvent 返回 false，表示 onTouchEvent 没对传入触摸事件 MotionEvent 处理

#### 4、Activity之前

- ViewRootImpl#WindowInputEventReceiver

  ```java
  final class WindowInputEventReceiver extends InputEventReceiver {
      //这个类负责监听来自底层的点击事件
      public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) {
          super(inputChannel, looper);
      }
  
      @Override
      public void onInputEvent(InputEvent event) {
          List<InputEvent> processedEvents;
          if (processedEvents != null) {
              if (processedEvents.isEmpty()) {
                  finishInputEvent(event, true);
              } else {
                  for (int i=0;i<processedEvents.size();i++){
                      //for遍历所有的事件
                      //调用enqueueInputEvent
                      enqueueInputEvent(processedEvents.get(i), this, QueuedInputEvent.FLAG_MODIFIED_FOR_COMPATIBILITY, true);
                  }
              }
          } else {
              enqueueInputEvent(event, this, 0, true);
          }
      }
  }
  ```

- ViewRootImpl#enqueueInputEvent

  ```java
  void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) {
      //...
      if (processImmediately) {
          //正常情况下都会立刻分发事件
          //在当前线程直接分发事件
          doProcessInputEvents();
      } else {
          //延迟处理，例如轨迹球这种事件
          //通过handler将事件发送到主线程
          scheduleProcessInputEvents();
      }
  }
  ```

- ViewRootImpl#doProcessInputEvents

  ```java
  void doProcessInputEvents() {
      //while遍历处理所有事件
      while (mPendingInputEventHead != null) {
          QueuedInputEvent q = mPendingInputEventHead;
          mPendingInputEventHead = q.mNext;
          if (mPendingInputEventHead == null) {
              mPendingInputEventTail = null;
          }
          q.mNext = null;
          //...
          deliverInputEvent(q);
      }
      //...
  }
  ```

- ViewRootImpl#deliverInputEvent

  ```java
  private void deliverInputEvent(QueuedInputEvent q) {
      InputStage stage;
      if (q.shouldSendToSynthesizer()) {
          stage = mSyntheticInputStage;
      } else {
          //将mFirstInputStage赋值给stage
          //mFirstInputStage是一个nativePreImeStage
          //nativePreImeStage的类NativePreImeInputStage与其他stage通过将自己作为其他stage参数，传进去构造，从而依次调用到每个stage的onProcess()方法（类似责任链模式）
  		/**
          InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
          InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
          InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
          InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);
          InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
          InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);
  		**/
          stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;
      }
  
      if (q.mEvent instanceof KeyEvent) {
          mUnhandledKeyManager.preDispatch((KeyEvent) q.mEvent);
      }
  
      if (stage != null) {
          handleWindowFocusChanged();
          //进入deliver
          stage.deliver(q);
      } else {
          finishInputEvent(q);
      }
  }
  ```

- ViewRootImpl#deliver

  ```java
  public final void deliver(QueuedInputEvent q) {
      if ((q.mFlags & QueuedInputEvent.FLAG_FINISHED) != 0) {
          forward(q);
      } else if (shouldDropInputEvent(q)) {
          finish(q, false);
      } else {
          //调用onProcess，View和Activity只需关注ViewPostImeInputStage
          apply(q, onProcess(q));
      }
  }
  ```

- ViewRootImpl#ViewPostImeInputStage#onProcess

  ```java
  final class ViewPostImeInputStage extends InputStage {
      public ViewPostImeInputStage(InputStage next) {
          super(next);
      }
  
      @Override
      protected int onProcess(QueuedInputEvent q) {
          if (q.mEvent instanceof KeyEvent) {
              return processKeyEvent(q);
          } else {
              final int source = q.mEvent.getSource();
              if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
                  //主要看这个
                  return processPointerEvent(q);
              } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
                  //轨迹球事件
                  return processTrackballEvent(q);
              } else {
                  //其他事件
                  return processGenericMotionEvent(q);
              }
          }
      }
  }
  ```

- ViewRootImpl#processPointerEvent

  ```java
  private int processPointerEvent(QueuedInputEvent q) {
      //将事件转化成MotionEvent
      final MotionEvent event = (MotionEvent)q.mEvent;
      //...
      //调用dispatchPointerEvent
      boolean handled = mView.dispatchPointerEvent(event);
      //...
      return handled ? FINISH_HANDLED : FORWARD;
  }
  ```

- View#dispatchPointerEvent

  ```java
  public final boolean dispatchPointerEvent(MotionEvent event) {
      if (event.isTouchEvent()) {
          //到达这一步后，事件已经传到控件树的顶级View,DecorView（虽然ViewRootImpl也实现了ViewParent，但只能算虚拟父View，更像是操作辅助类）
          return dispatchTouchEvent(event);
      } else {
          return dispatchGenericMotionEvent(event);
      }
  }
  ```

- DecorView#dispatchTouchEvent

  ```java
  @Override
  public boolean dispatchTouchEvent(MotionEvent ev) {
      //mWindow是PhoneWindow，Activity在attach创建完PhoneWindow后，将自己设为PhoneWindow的callBack，所以这里是在调用Activity的dispatchTouchEvent
      //事件从这里开始脱离控件树，进入Activity
      final Window.Callback cb = mWindow.getCallback();
      return cb != null && !mWindow.isDestroyed() && mFeatureId < 0 ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);
  }
  ```

- Activity#dispatchTouchEvent

  ```java
  public boolean dispatchTouchEvent(MotionEvent ev) {
      if (ev.getAction() == MotionEvent.ACTION_DOWN) {
          //屏保事件
          onUserInteraction();
      }
      //getWindow是PhoneWindow，在这里会进入控件树的事件分发
      if (getWindow().superDispatchTouchEvent(ev)) {
          return true;
      }
      //如果上面为false，也就是view不处理事件，就Activity自己处理
      return onTouchEvent(ev);
  }
  ```

- 总结

  - 触摸事件生成，交由系统底层驱动处理后交给IMS

    - Touch事件的分发分服务端和应用端。在服务端由WMS（借助IMS）负责采集和分发的，在应用端由ViewRootImpl（内部变量mView指向View树的根，负责控制View树的UI绘制和事件消息的分发）负责
    - WMS启动后，在Native层启动两个线程：InputReaderThread和InputDispachThread，前者读取输入事件，后者分发输入事件，输入事件经过Native层，最终传到Java层的ViewRootImpl中，调用ViewPostImeInputState（ViewRootImpl内部类）各方法来分发事件，Touch事件在processPointerEvent方法进行分发
    - processPointerEvent调用mView.processPointerEvent(event)方法，这里的mView就是在创建窗口后通过调用root,setView传进来的DecorView，processPointerEvent方法对event进行判断，如果是Touch事件就调用dispatchTouchEvent将该事件分发给DecorView，这样Touch事件就传递到了View树中

  - IMS（InputManagerService）从WMS获取到对应窗口的信息

    - IMS监听/dev/input下的所有的设备节点，当设备节点有数据时会将数据进行加工处理并找到合适的Window，将输入事件派发给其

    - WMS作为输入系统的中转站、Window的管理者，配合IMS将输入事件交由合适的Window处理

    - ViewRootImpl通过WMS调用IMS的相关方法获取InputChannel

    - Touch事件从server端传递到client端采用的IPC方式是共享内存和管道，共享内存效率更高，管道（两个，分别负责不同方向的读和写）只负责通知是否有事件发生，传递的只是一个简单的字符串，并不太多地影响IPC效率

    - 实际的分发操作在InputPublish中进行，其保存有一个指向server端InputChannel的指针，和一个指向ShareMemory（共享内存）的指针，当有事件要分发时，将事件写入到ShareMemory中，且传递一个特定字符串给InputChannel，由InutChannel将该字符串写入到管道中；在client端，一旦InputChannel从管道中读取到有事件分发过来，便通知InPutConsumer从ShareMemory中读取具体事件，并传到framework层的InputQueue中，一旦事件消费完毕，client端通过管道告诉server端事件已经消费完毕，流程与上面类似

    - 这两个InputChannel在native层，在framework层各有一个对应的InputChannel类

      > client端的在ViewRootImpl的setView中new出来，但未做任何初始化（真正初始化是跟server端的一起在WMS中执行），构造方法为空
      >
      > server端的在server端创建，但创建过程是在client端发起，ViewRootImpl有server端的Session的代理，同样是setview方法中，通过Session代理执行server端Session的addToDisplay方法，该方法接受了client端的InputChannel方法
      >
      > addToDisplay方法会调用WindowManagerService的addWindow方法，两个InputChannel的初始化都在这里进行
      >
      > 借助InputChannel事件被传到Framework层

    <img src="https://img-blog.csdnimg.cn/20190914050249562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pzb25faXQ=,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

  - 将信息传递给ViewRootImpl，ViewRootImpl将事件封装成MotionEvent

    ![img](https://img-blog.csdnimg.cn/20190914125606422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pzb25faXQ=,size_16,color_FFFFFF,t_70)

  - ViewRootImpl将事件发送给它所管理的View树的根节点DecorView

  - DecorView将事件传递给Activity，而Activity又通过PhoneWindow将事件传回DecorView

  - DecorView调用父类ViewGroup的分发方法，进入常规流程

<img src="https://img-blog.csdnimg.cn/20190912083811782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pzb25faXQ=,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDE5LzA1LzI3L1ZaSEJCZC5wbmc?x-oss-process=image/format,png" alt="img" style="zoom:67%;" />