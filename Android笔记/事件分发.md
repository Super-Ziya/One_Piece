### 事件分发

<img src="https://img-blog.csdn.net/20151219223049372" alt="这里写图片描述" style="zoom:67%;" />

- Activity - ViewGroup - View，从外向内依次调用 dispatchTouchEvent 方法，Android 依次把 MotionEvent 参数传给该方法。dispatchTouchEvent 的作用是传递触摸事件。将触摸事件从外向内逐级传递派发，dispatchTouchEvent 是每次传递触摸事件的入口
- View - ViewGroup - Activity，从内向外依次调用 onTouchEvent 方法，Android 依次把 MotionEvent 参数传给该方法。onTouchEvent 的作用是处理触摸事件。将触摸事件从内向外逐级处理

#### 1、Activity

- dispatchTouchEvent：所有 UI 上的触摸操作生成的触摸事件会先触发 Activity 中 dispatchTouchEvent 方法

  ```java
  public boolean dispatchTouchEvent(MotionEvent ev) {
      if (ev.getAction() == MotionEvent.ACTION_DOWN) {
          onUserInteraction();
      }
      if (getWindow().superDispatchTouchEvent(ev)) {
          return true;
      }
      return onTouchEvent(ev);
  }
  ```

  > Activity 先通过 `getWindow()` 获取当前 window 对象（返回一个 PhoneWindow 类型实例），调用 window 的 superDispatchTouchEvent 方法，会调用 PhoneWindow 的 superDispatchTouchEvent 方法

  ```java
  @Override
  public boolean superDispatchTouchEvent(MotionEvent event) {
      return mDecor.superDispatchTouchEvent(event);
  }
  ```

  > mDecor 是 PhoneWindow 中一个 DecorView 类型变量，DecorView 代表当前 Window 最顶级 View（根View）。然后执行 DecorView 的 superDispatchTouchEvent 方法

  ```java
  public boolean superDispatchTouchEvent(MotionEvent event) {
      return super.dispatchTouchEvent(event);
  }
  ```

  > DectorView 继承自 FrameLayout，间接继承自 ViewGroup，DectorView 执行父类 ViewGroup 对应的 dispatchTouchEvent 方法
  >
  > 该方法中，DectorView 会找到其触摸的子节点（ViewGroup），然后执行该 ViewGroup 的 dispatchTouchEvent 方法，实现将触摸事件参数 MotionEvent 从 Activity 传入 DecorView 子 ViewGroup 中

- superDispatchTouchEvent 和 dispatchTouchEvent 方法均返回一个 boolean 类型的参数，true 表示触摸事件被处理，如果 PhoneWindow 的 superDispatchTouchEvent 返回 true，Activity 的 dispatchTouchEvent 直接返回 true，表明触摸事件被 Window 处理，不会执行 Activity 的 onTouchEvent 方法。只有 Window 没处理触摸事件，Activity 才会调用 onTouchEvent 方法处理

  ```java
  public boolean onTouchEvent(MotionEvent event) {
      if (mWindow.shouldCloseOnTouch(this, event)) {
          finish();
          return true;
      }
      return false;
  }
  ```

  > 当触摸事件没有被任何 View 或 ViewGroup 处理时，Activity 才会执行自己的 onTouchEvent 处理
  >
  > PS：当前触摸点在 Window 范围外，这样 Window 里所有 View 都不会接收更不会处理该触摸事件，这时可重写该方法实现逻辑处理，处理就返回 true，否则返回 false，默认实现基本一直返回 false

#### 2、ViewGroup

- dispatchTouchEvent：

  - Activity 收到触摸事件后，通过 DectorView 调用 ViewGroup 的 dispatchTouchEvent 方法（ViewGroup 对触摸事件进行处理的入口）
  - ViewGroup 定义一个 TouchTarget 类型的成员变量 mFirstTouchTarget 用于保存当前 ViewGroup 中处理触摸事件的子 View
  - dispatchTouchEvent 调用自身 onInterceptTouchEvent 方法（拦截 ViewGroup 将触摸事件传给子 View，返回 true 表示 ViewGroup 拦截触摸事件，false 表示不拦截，将触摸事件传给子 View），dispathTouchEvent 定义一个 boolean 类型 handled 变量用于保存 dispathTouchEvent 返回值
  - onInterceptTouchEvent 返回 false，ViewGroup 才会依次遍历子 View，通过 isTransformedTouchPointInView 方法判断 MotionEvent 触摸事件坐标是否落在子 View 范围内，在范围内 ViewGroup 把触摸事件坐标及子 View 传给 dispatchTransformedTouchEvent 方法，该方法调用子 View 的 dispatchTouchEvent 方法，返回值表示 View 是否处理触摸事件，dispatchTransformedTouchEvent 返回 true 表示子 View 处理触摸事件，ViewGroup 通过 addTouchTarget 将 mFirstTouchTarget 绑定子 View，且变量 alreadyDispatchedToNewTouchTarget 设 true 表示有子 View 处理触摸事件。有子 View 处理触摸事件 ViewGroup 通过 break 跳出子 View 遍历 for 循环
  - 对子 View for 循环后，没有子 View 处理触摸事件，mFirstTouchTarget 是 null，ViewGroup 将 null 作为 child 参数传入 dispatchTransformedTouchEvent 方法中，该方法调用 super.dispatchTouchEvent 方法，ViewGroup 继承自 View，相当执行 View 类的 dispatchTouchEvent 方法，可能会执行 ViewGroup 从 View 中继承来的 onTouchEvent 方法。dispatchTransformedTouchEvent 的返回值作为局部变量 handled
  - 对子 View for 循环后某个子 View 处理触摸事件，alreadyDispatchedToNewTouchTarget 是 true，将局部变量 handled 设为 true，表示只要有子 View 处理触摸事件，当前 ViewGroup 也处理触摸事件，ViewGroup 不会调用从 View 继承的 dispatchTouchEvent 方法，不触发 ViewGroup 的 onTouchEvent 方法执行

- onInterceptTouchEvent：用于拦截 ViewGroup 向子 View 传递触摸事件，默认实现一直返回 false，表示不拦截

- dispatchTransformedTouchEvent

  ```java
  private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,View child, int desiredPointerIdBits){
      final boolean handled;
      final MotionEvent transformedEvent;
      //......        
      // 执行任何必要的转换和调度
      if (child == null) {
          handled = super.dispatchTouchEvent(transformedEvent);
      } else {
          final float offsetX = mScrollX - child.mLeft;
          final float offsetY = mScrollY - child.mTop;
          transformedEvent.offsetLocation(offsetX, offsetY);
          if (! child.hasIdentityMatrix()) {
              transformedEvent.transform(child.getInverseMatrix());
          }
          handled = child.dispatchTouchEvent(transformedEvent);
      }
      // Done.
      transformedEvent.recycle();
      return handled;
  }
  ```
  > 将 MotionEvent 的 x、y 坐标转换成所传入 child 变量指定 View 的坐标系坐标，
  >
  > transformedEvent：已完成指定坐标系转换的 MotionEvent，如果传入 child 是 null，表示传入当前 ViewGroup，直接调用 `super.dispatchTouchEvent(transformedEvent)`，让 ViewGroup 调用父类 View 的 dispatchTouchEvent 方法；如果不是 null，表示传入当前 ViewGroup 一个子 View，会调用 `child.dispatchTouchEvent(transformedEvent)`，将触摸事件从 ViewGroup 传到子 View 中

- onTouchEvent
  - ViewGroup 的 onTouchEvent 继承自 View 的 onTouchEvent 方法，ViewGroup 没有重写

#### 3、View

- dispatchTouchEvent：View处理触摸事件的入口

  ```java
  public boolean dispatchTouchEvent(MotionEvent event) {
      //......
      boolean result = false;
      //......
      if (onFilterTouchEventForSecurity(event)) {
          //无检验简化If语句
          ListenerInfo li = mListenerInfo;
          //如果设置OnTouchListener，在此处执行OnTouchListener的onTouch方法
          if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
              //如果OnTouchListener的onTouch方法返回true，表示触摸事件被处理，result会设为true
              result = true;
          }
          //如果触摸事件没被OnTouchListener处理，执行View的onTouchEvent方法
          if (!result && onTouchEvent(event)) {
              //如果onTouchEvent返回true，表示触摸事件被View处理，result被设为true
              result = true;
          }
      }
      //......
      return result;
  }
  ```
  > View 先查看其有没有设过 OnTouchListener，设过就调用 OnTouchListener 的 onTouch 方法，返回 true 表明触摸事件被处理，result 设为 true。没有被处理会执行 View 的 onTouchEvent 方法，如果 onTouchEvent 返回 true，表示触摸事件被 View 处理，result 设为 true
  >
  > dispatchTouchEvent 方法先执行 OnTouchListener 的 onTouch 方法，返回 true 就不会调用 View 的 onTouchEvent 方法，只有 OnTouchListener 没有处理触摸事件才会执行 View 的 onTouchEvent 方法

- onTouchEvent

  - `View.onTouchEvent()` 方法中，如果 View 注册了 CLICK 或 LONG_CLICK 等事件监听器，会让注册的事件监听器处理触摸事件，onTouchEvent 返回 true。根据 ACTION 不同执行不同处理，如 ACTION_UP 会执行 `performClick()` 方法，该方法会触发 `OnClickListener.onClick()` 执行
  - 如果 View 没注册任何 CLICK 或 LONG_CLICK 等事件监听器，onTouchEvent 返回 false，表示 onTouchEvent 没对传入触摸事件 MotionEvent 处理