### 内存泄露分析

- 指程序在申请内存后，无法释放已申请的内存空间，造成应用程序OOM的主要原因之一

#### 1、static关键字修饰的成员变量

- static修饰context造成的内存泄漏

  > static修饰成员变量时，该变量就属于该类，而不是该类的实例，使得变量的生命周期大大延长，访问的方便，用类名就能直接访问，各个资源间传值也极其的方便，所以它经常被使用。但如果用它来引用一些资源耗费过的实例（Context的情况最多），这时就要谨慎对待了。

  ```java
  public class ClassName {   
        private static Context mContext;   
        //... 
  } 
  ```

  - 如果将Activity赋值到mContext，即使该Activity已经onDestroy，但是由于仍有对象保存它的引用，因此该Activity依然不会被释放，如果该Activity里面再持有一些资源，那就更糟糕了
  - 解决
    - 尽量避免 Static 成员变量引用资源耗费过多的实例（如Context）
    - 使用弱引用WeakReference代替强引用持有实例。如可以使用WeakReference mContextRef

- 单例造成的内存泄漏

  > 单例的静态特性使得单例的生命周期和应用的生命周期一样长，如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，导致内存泄漏

  ```java
  public class BankManager {
      private static BankManager instance;
      private Context context;
  
      private BankManager(Context context) {
          this.context = context;
      }
  
      public static BankManager getInstance(Context context) {
          if (instance == null) {
              instance = new BankManager(context);
          }
          return instance;
      }
  }
  ```
  - 创建这个单例的时候，需要传入一个Context，所以这个Context的生命周期的长短至关重要
    - 传入Application的Context：单例的生命周期和Application的一样长，这将没有任何问题
    - 传入Activity的Context：由于该Context和Activity的生命周期一样长(Activity间接继承于Context)，单例的生命周期可能大于Activity的生命周期。当这个Context所对应的Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用
  - 解决：Context 尽量使用Application Context，正确的单例：

  ```java
  public class BankManager {
      private static BankManager instance;
      private Context context;
  
      private BankManager(Context context) {
          this.context = context.getApplicationContext();
      }
  
      public static BankManager getInstance(Context context) {
          if (instance != null) {
              instance = new BankManager(context);
          }
          return instance;
      }
  }
  ```

#### 2、非静态内部类/匿名类

- 非静态内部类创建静态实例造成的内存泄漏

  > 在启动频繁的Activity中，为了避免重复创建相同的数据资源，会在Activity内部创建一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据。若非静态内部类所创建的实例的生命周期等于应用的生命周期，会因非静态内部类持有外部类的引用，而导致外部类无法释放，最终造成内存泄露

  ```java
  public class MainActivity extends AppCompatActivity {
      private static TestResource mResource = null;
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_main);
          if(mResource == null){
              mResource = new TestResource();
          }
          //...
      }
      
      private class TestResource {
          //...
      }
  }
  ```
  - 在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，虽然避免资源的重复创建，却会造成内存泄漏。非静态内部类会持有外部类的引用，而又使用非静态内部类创建静态实例，该实例和应用的生命周期一样长，导致该静态实例一直会持有Activity的引用，导致Activity的内存资源不能回收
  - 解决
    - 将非静态内部类改为静态内部类（静态内部类默认不持有外部类的引用）
    - 该内部类抽取出来封装成一个单例。若需使用Context，建议使用 Application 的 Context

- Handler造成的内存泄漏

  ```java
  public class MainActivity extends AppCompatActivity {
      private Handler mHandler = new Handler() {
          @Override
          public void handleMessage(Message msg) {
              //...doSomething
          }
      };
      
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_main);
          loadData();
      }
      
      private void loadData(){
          //...request http
          Message message = Message.obtain();
          mHandler.sendMessage(message);
      }
  }
  ```

  - mHandler是Handler的非静态匿名内部类实例，持有外部类Activity的引用，消息队列MessageQueue在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时，消息队列中还有未处理的消息Message或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏
  - 解决
    - 创建一个静态Handler内部类，对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，Looper线程的消息队列中还是可能会有待处理的消息，所以在Activity的Destroy时或者Stop时应该移除消息队列中的消息

  ```java
  public class MainActivity extends AppCompatActivity {
      private MyHandler mHandler;
      private TextView mTextView;
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_main);
          mTextView = (TextView)findViewById(R.id.textview);
          mHandler = new MyHandler(this);
          loadData();
      }
      private void loadData() {
          //...request http
          Message message = Message.obtain();
          mHandler.sendMessage(message);
      }
  
      private static class MyHandler extends Handler {
          private WeakReference<Context> reference;
          
          public MyHandler(Context context) {
              reference = new WeakReference<>(context);
          }
          
          @Override
          public void handleMessage(Message msg) {
              MainActivity activity = (MainActivity) reference.get();
              if(activity != null){
                  activity.mTextView.setText("请求成功");
              }
          }
      }
  
      @Override
      protected void onDestroy() {
          super.onDestroy();
          mHandler.removeCallbacksAndMessages(null);
      }
  }
  ```

- 多线程造成的内存泄漏（AsyncTask、实现Runnable接口、继承Thread类）

  > 工作线程Thread类属于非静态内部类/匿名内部类，运行时默认持有外部类的引用。当工作线程运行时，若外部类MainActivity需销毁，由于此时工作线程类实例持有外部类的引用，将使得外部类无法被垃圾回收器（GC）回收，从而造成内存泄露

  ```java
  new AsyncTask<Void, Void, Void>() {
      @Override
      protected Void doInBackground(Void... params) {
          SystemClock.sleep(10000);
          return null;
      }
  }.execute();
  
  new Thread(new Runnable() {
      @Override
      public void run() {
          SystemClock.sleep(10000);
      }
  }).start();
  ```

  - 解决
    - 静态内部类不持有外部类的引用，使得工作线程实例不会持有外部类引用
    - 当外部类结束生命周期时，强制结束线程，使得工作线程实例的生命周期与外部类的生命周期同步

  ```java
  public class MainActivity extends AppCompatActivity {
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_main);
          new Thread(new MyRunnable()).start();
      }
  
      static class MyRunnable implements Runnable{
          @Override
          public void run() {
              SystemClock.sleep(10000);
          }
      }
  
      @Override
      protected void onDestroy() {
          super.onDestroy();
          Thread.stop();// 外部类Activity生命周期结束时，强制结束线程
      }
  }
  ```

#### 3、资源未关闭造成的内存泄漏

> 对于资源的使用（如广播BraodcastReceiver、文件流File、数据库游标Cursor、图片资源Bitmap等），若在Activity销毁时无及时关闭或者注销这些资源，这些资源将不会被回收，从而造成内存泄漏

- 解决：在Activity销毁时及时关闭或者注销资源

  ```java
  //广播BraodcastReceiver：注销注册
  unregisterReceiver()
  
  //文件流File：关闭流
  InputStream/OutputStream.close()
  
  //数据库游标cursor：使用后关闭游标
  cursor.close()
  
  //图片资源Bitmap：当它不再被使用时，应调用recycle()回收此对象的像素所占用的内存；最后再赋为null
  Bitmap.recycle()
  Bitmap = null
  ```







