### 工厂模式

> 属于创建型模式，提供一种创建对象的最佳方式，创建对象时不会对客户端暴露创建逻辑，且通过使用一个共同接口指向新创建对象

- 意图：定义一个创建对象的接口，让其子类决定实例化哪个工厂类，工厂模式使其创建过程延迟到子类进行
- 解决：接口选择问题
- 适用：明确不同条件创建不同实例
- 使用：让其子类实现工厂接口，返回一个抽象产品
- 如：
  - 一辆汽车可直接从工厂里提货，不用管怎么造出来，及其具体实现
  - Hibernate 换数据库只需换方言和驱动即可

- 优点：
  - 调用者创建一个对象，只要知道其名称即可
  - 扩展性高，增加一个产品，只要扩展一个工厂类即可
  - 屏蔽产品具体实现，调用者只关心产品接口
- 缺点：每增加一个产品都需增加一个具体类和对象实现工厂，使类个数成倍增加，一定程度增加系统复杂度、具体类的依赖
- 使用场景：
  - 日志记录器：可能记录到本地硬盘、系统事件、远程服务器等，用户选择记录日志到什么地方
  - 数据库访问：当用户不知道系统采用哪一类数据库，及数据库可能变化时
  - 设计一个连接服务器框架，需要三个协议：POP3、IMAP、HTTP，可其作为产品类，共同实现一个接口
- 注意：任何需生成复杂对象的地方，都可使用工厂方法模式，简单对象如果使用工厂模式，会增加系统复杂度

![工厂模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)

### 抽象工厂模式

> 属于创建型模式，提供一种创建对象的最佳方式，围绕一个超级工厂创建其他工厂，该超级工厂是其他工厂的工厂，接口负责创建一个相关对象的工厂，不需显式指定类，每个生成的工厂按照工厂模式提供对象

- 意图：提供一个创建一系列相关或相互依赖对象的接口，无需指定具体类
- 解决：接口选择问题
- 适用：系统产品有多于一个的产品族，系统只消费其中某一族产品
- 使用：在一个产品族里定义多个产品
- 如：多套衣服：商务装、时尚装等，都是成套的（一系列具体产品），某个衣柜（具体工厂）只能存放某种套衣服，每次拿衣服从该衣柜取出，OOP （面向对象）思想，所有衣柜（具体工厂）都是衣柜类（抽象工厂）的某一个，每套衣服包括具体上衣，裤子等（具体产品），具体上衣、裤子都是上衣、裤子（抽象产品）
- 优点：当一个产品族中多个对象被设计成一起工作时，能保证客户端始终只用同一个产品族中的对象
- 缺点：产品族扩展困难，增加一个系列某一产品，要在抽象和具体的 Creator 里修改
- 使用场景：
  - 游戏换皮肤，一整套一起换
  - 生成不同操作系统的程序
- 注意：产品族难扩展，产品等级易扩展

![img](https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg)