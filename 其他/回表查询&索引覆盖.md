### 回表查询 & 索引覆盖

- 例：*select id,name where name='shenjian'*、*select id,name*_,sex_ *where name='shenjian'*，多查询一个属性，检索过程完全不同

- MySQL 基本字段类型标识

  - PK: primary key，主键
  - NN: not null，非空
  - UQ: unique，唯一
  - AI: auto increment，自增

- MySQL 扩展数据类型标记

  - BIN: binary，二进制(比text更大的二进制数据)
  - UN: unsigned，整数
  - ZF: zero fill，值中最有意义的字节总为0，并且不保存

- InnoDB 索引

  - 聚集索引 (clustered index)：叶子节点存储行记录，InnoDB 必须要有，且只有一个聚集索引
    - 如果表定义了 PK，则 PK 就是聚集索引
    - 如果表没有定义 PK，则第一个 NN UQ 列是聚集索引
    - 否则，InnoDB 会创建一个隐藏的 row-id 作为聚集索引
  - 普通索引 (secondary index)：叶子节点存储主键值

- 如有一个表：

  - id 为 PK，聚集索引，叶子节点存储行记录
  - name 为 KEY，普通索引，叶子节点存储 PK 值，即 id

  |  1   | shenjian |  m   |  A   |
  | :--: | :------: | :--: | :--: |
  |  3   | zhangsan |  m   |  A   |
  |  5   |   lisi   |  m   |  A   |
  |  9   |  wangwu  |  f   |  B   |

  ![image-20210704115647906](C:\Users\13085\AppData\Roaming\Typora\typora-user-images\image-20210704115647906.png)

  - 从普通索引无法直接定位行记录，通常情况下，需要扫描两遍索引树
    - 先通过普通索引定位到主键值 id=5
    - 在通过聚集索引定位到行记录
    - 这就是**回表查询**，先定位主键值，再定位行记录，性能较扫一遍索引树更低

  ![image-20210704115833647](C:\Users\13085\AppData\Roaming\Typora\typora-user-images\image-20210704115833647.png)

- 索引覆盖：只需要在一棵索引树上就能获取 SQL 所需的所有列数据，无需回表，速度更快。